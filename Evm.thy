chapter {* Generated by Lem from evm.lem. *}

theory "Evm" 

imports 
 	 Main
	 "Lem_pervasives" 
	 "Lem_word" 
	 "Word256" 
	 "Word160" 
	 "Word8" 

begin 


(*open import Pervasives*)
(*open import Word*)
(*open import Word256*)
(*open import Word160*)
(*open import Word8*)

type_synonym uint ="  256 word "
type_synonym address ="  160 word "
type_synonym byte ="  8 word "

(*val sintFromW256 : uint -> int*)
definition sintFromW256  :: " 256 word \<Rightarrow> int "  where 
     " sintFromW256 = ( sint )"


(*val uint : uint -> int*)
definition uint  :: " 256 word \<Rightarrow> int "  where 
     " uint w = ( int (unat w))"


(*
val word256ToNat : uint -> nat
let word256ToNat = word256ToNat
*)

(*val absnat : uint -> nat*)
definition absnat  :: " 256 word \<Rightarrow> nat "  where 
     " absnat w = ( nat (abs (sint w)))"


(*val byteFromNat : nat -> byte*)
definition byteFromNat  :: " nat \<Rightarrow> 8 word "  where 
     " byteFromNat = ( word8FromNat )"


(*
val word_of_int : int -> uint
let word_of_int = word256FromInt
*)

(*val uint_of_bl : list bool -> uint*)
definition uint_of_bl  :: "(bool)list \<Rightarrow> 256 word "  where 
     " uint_of_bl = ( of_bl )"


(*val uint_to_address : uint -> address*)
(*let uint_to_address w=  word160FromNat (word256ToNat w)*)

(*val address_to_uint : address -> uint*)
(*let address_to_uint w=  word256FromNat (word160ToNat w)*)

(*val uint_to_byte : uint -> byte*)
(*let uint_to_byte w=  word8FromNat (word256ToNat w)*)

(*val byte_to_uint : byte -> uint*)
(*let byte_to_uint w=  word256FromNat (word8ToNat w)*)

(*val keccac : list byte -> uint*)
definition keccac  :: "(byte)list \<Rightarrow> 256 word "  where 
     " keccac _ = (((word_of_int 0) ::  256 word))"


(*val test_bit : uint -> nat -> bool*)
definition test_bit  :: " 256 word \<Rightarrow> nat \<Rightarrow> bool "  where 
     " test_bit w n = (
  if (w AND (((word_of_int 1) ::  256 word) >> n)) =((word_of_int 0) ::  256 word) then False
  else True )"


(*val word_rsplit_aux : list bool -> nat -> list byte*)
fun  word_rsplit_aux  :: "(bool)list \<Rightarrow> nat \<Rightarrow>( 8 word)list "  where 
     " word_rsplit_aux lst 0 = ( [])"
|" word_rsplit_aux lst ((Suc n)) = ( of_bl (List.take(( 8 :: nat)) lst) # word_rsplit_aux (List.drop(( 8 :: nat)) lst) n )" 
declare word_rsplit_aux.simps [simp del]


(*val word_rsplit : uint -> list byte*)
(*let word_rsplit w=  word_rsplit_aux (boolListFromWord256 w) 32*)

(*val get_byte : uint -> uint -> uint*)
definition get_byte  :: " 256 word \<Rightarrow> 256 word \<Rightarrow> 256 word "  where 
     " get_byte position w = (
  (case  index (word_rsplit w) (absnat position) of
    None =>((word_of_int 0) ::  256 word)
  | Some (a::byte) => Word.ucast a
  ))"


type_synonym memory =" uint \<Rightarrow> byte "
type_synonym storage =" uint \<Rightarrow> uint "

(*val empty_storage : storage*)
definition empty_storage  :: " 256 word \<Rightarrow> 256 word "  where 
     " empty_storage _ = (((word_of_int 0) ::  256 word))"


record aenv = 

  aenv_stack ::" uint list " 

  aenv_memory ::" memory " 

  aenv_storage ::" storage " 

  aenv_balance ::" address \<Rightarrow> uint " 

  aenv_caller ::" address " 

  aenv_value_sent ::" uint " 

  aenv_data_sent ::" byte list " 

  aenv_storage_at_call ::" storage " 

  aenv_balance_at_call ::" address \<Rightarrow> uint " 

  aenv_this ::" address " 

  aenv_origin ::" address " 



datatype bits_inst =
  inst_AND (* bitwise AND *)
| inst_OR  (* bitwise OR *)
| inst_XOR (* bitwise exclusive or *)
| inst_NOT (* bitwise negation *)
| BYTE     (* taking one byte out of a word *)

(*val bits_inst_code : bits_inst -> byte*)
fun bits_inst_code  :: " bits_inst \<Rightarrow> 8 word "  where 
     " bits_inst_code inst_AND = (((word_of_int 22) ::  8 word))"
|" bits_inst_code inst_OR = (((word_of_int 23) ::  8 word))"
|" bits_inst_code inst_XOR = (((word_of_int 24) ::  8 word))"
|" bits_inst_code inst_NOT = (((word_of_int 25) ::  8 word))"
|" bits_inst_code BYTE = (((word_of_int 26) ::  8 word))" 
declare bits_inst_code.simps [simp del]



datatype sarith_inst =
  SDIV (* signed division *)
| SMOD (* signed modulo *)
| SGT  (* signed greater-than *)
| SLT  (* signed less-than *)
| SIGNEXTEND (* extend the size of a signed number *)

(*val sarith_inst_code : sarith_inst -> byte*)
fun sarith_inst_code  :: " sarith_inst \<Rightarrow> 8 word "  where 
     " sarith_inst_code SDIV = (((word_of_int 5) ::  8 word))"
|" sarith_inst_code SMOD = (((word_of_int 7) ::  8 word))"
|" sarith_inst_code SGT = (((word_of_int 19) ::  8 word))"
|" sarith_inst_code SLT = (((word_of_int 18) ::  8 word))"
|" sarith_inst_code SIGNEXTEND = (((word_of_int 11) ::  8 word))" 
declare sarith_inst_code.simps [simp del]


datatype arith_inst =
  ADD (* addition *)
| MUL (* multiplication *)
| SUB (* subtraction *) 
| DIV (* unsigned division *)
| MOD (* unsigned modulo *)
| ADDMOD (* addition under modulo *)
| MULMOD (* multiplication under modulo *)
| EXP (* exponentiation *)
| inst_GT (* unsigned greater-than *)
| inst_EQ (* equality *)
| inst_LT (* unsigned less-than *)
| ISZERO (* if zero, returns one *)
| SHA3 (* Keccak 256, dispite the name *)

(*val arith_inst_code : arith_inst -> byte*)
fun arith_inst_code  :: " arith_inst \<Rightarrow> 8 word "  where 
     " arith_inst_code ADD = (((word_of_int 1) ::  8 word))"
|" arith_inst_code MUL = (((word_of_int 2) ::  8 word))"
|" arith_inst_code SUB = (((word_of_int 3) ::  8 word))"
|" arith_inst_code DIV = (((word_of_int 4) ::  8 word))"
|" arith_inst_code MOD = (((word_of_int 6) ::  8 word))"
|" arith_inst_code ADDMOD = (((word_of_int 8) ::  8 word))"
|" arith_inst_code MULMOD = (((word_of_int 9) ::  8 word))"
|" arith_inst_code EXP = (((word_of_int 10) ::  8 word))"
|" arith_inst_code inst_GT = (((word_of_int 17) ::  8 word))"
|" arith_inst_code inst_LT = (((word_of_int 16) ::  8 word))"
|" arith_inst_code inst_EQ = (((word_of_int 20) ::  8 word))"
|" arith_inst_code ISZERO = (((word_of_int 21) ::  8 word))"
|" arith_inst_code SHA3 = (((word_of_int 32) ::  8 word))" 
declare arith_inst_code.simps [simp del]


datatype info_inst =
    ADDRESS (* The address of the account currently running *)
  | BALANCE (* The Eth balance of the specified account *)
  | ORIGIN (* The address of the external account that started the transaction *)
  | CALLER (* The immediate caller of this invocation *)
  | CALLVALUE (* The Eth amount sent along this invocation *)
  | CALLDATASIZE (* The number of bytes sent along this invocation *)
  | CODESIZE (* The number of bytes in the code of the account currently running *)
  | GASPRICE (* The current gas price *)
  | EXTCODESIZE (* The size of a code of the specified account *)
  | BLOCKHASH (* The block hash of a specified block among the recent blocks. *)
  | COINBASE (* The address of the miner that validates the current block. *)
  | TIMESTAMP (* The date and time of the block. *)
  | NUMBER (* The block number *)
  | DIFFICULTY (* The current difficulty *)
  | GASLIMIT (* The current block gas limit *)
  | GAS (* The remaining gas for the current execution. This changes after every instruction
  is executed.  *)
  
(*val info_inst_code : info_inst -> byte*)
fun info_inst_code  :: " info_inst \<Rightarrow> 8 word "  where 
     " info_inst_code ADDRESS = (((word_of_int 48) ::  8 word))"
|" info_inst_code BALANCE = (((word_of_int 49) ::  8 word))"
|" info_inst_code ORIGIN = (((word_of_int 50) ::  8 word))"
|" info_inst_code CALLVALUE = (((word_of_int 52) ::  8 word))"
|" info_inst_code CALLDATASIZE = (((word_of_int 54) ::  8 word))"
|" info_inst_code CALLER = (((word_of_int 51) ::  8 word))"
|" info_inst_code CODESIZE = (((word_of_int 56) ::  8 word))"
|" info_inst_code GASPRICE = (((word_of_int 58) ::  8 word))"
|" info_inst_code EXTCODESIZE = (((word_of_int 59) ::  8 word))"
|" info_inst_code BLOCKHASH = (((word_of_int 64) ::  8 word))"
|" info_inst_code COINBASE = (((word_of_int 65) ::  8 word))"
|" info_inst_code TIMESTAMP = (((word_of_int 66) ::  8 word))"
|" info_inst_code NUMBER = (((word_of_int 67) ::  8 word))"
|" info_inst_code DIFFICULTY = (((word_of_int 68) ::  8 word))"
|" info_inst_code GASLIMIT = (((word_of_int 69) ::  8 word))"
|" info_inst_code GAS = (((word_of_int 90) ::  8 word))" 
declare info_inst_code.simps [simp del]


type_synonym dup_inst =" byte "

(*val dup_inst_code : dup_inst -> maybe byte*)
definition dup_inst_code  :: " 8 word \<Rightarrow>( 8 word)option "  where 
     " dup_inst_code m = (
   if word_sless m(((word_of_int 1) ::  8 word)) then None (*-- There is no DUP0 instruction. *)
   else if word_sless (((word_of_int 16) ::  8 word)) m then None (* -- There are no DUP16 instruction and on. *)
   else Some (m +((word_of_int 127) ::  8 word)))"


datatype memory_inst =
  MLOAD (* reading one machine word from the memory, beginning from the specified offset *)
| MSTORE (* writing one machine word to the memory *)
| MSTORE8 (* writing one byte to the memory *)
| CALLDATACOPY (* copying the caller's data to the memory *)
| CODECOPY (* copying a part of the currently running code to the memory *)
| EXTCODECOPY (* copying a part of the code of the specified account *)
| MSIZE (* the size of the currently used region of the memory. *)

(*val memory_inst_code : memory_inst -> byte*)
fun memory_inst_code  :: " memory_inst \<Rightarrow> 8 word "  where 
     " memory_inst_code MLOAD = (((word_of_int 81) ::  8 word))"
|" memory_inst_code MSTORE = (((word_of_int 82) ::  8 word))"
|" memory_inst_code MSTORE8 = (((word_of_int 83) ::  8 word))"
|" memory_inst_code CALLDATACOPY = (((word_of_int 55) ::  8 word))"
|" memory_inst_code CODECOPY = (((word_of_int 57) ::  8 word))"
|" memory_inst_code EXTCODECOPY = (((word_of_int 60) ::  8 word))"
|" memory_inst_code MSIZE = (((word_of_int 89) ::  8 word))" 
declare memory_inst_code.simps [simp del]


datatype storage_inst =
  SLOAD (* reading one word from the storage *)
| SSTORE (* writing one word to the storage *)

(*val storage_inst_code : storage_inst -> byte*)
fun storage_inst_code  :: " storage_inst \<Rightarrow> 8 word "  where 
     " storage_inst_code SLOAD = (((word_of_int 84) ::  8 word))"
|" storage_inst_code SSTORE = (((word_of_int 85) ::  8 word))" 
declare storage_inst_code.simps [simp del]


datatype pc_inst =
   JUMP (* jumping to the specified location in the code *)
 | JUMPI (* jumping to the specified location in the code if a condition is met *)
 | PC (* the current location in the code *)
 | JUMPDEST (* a no-op instruction located to indicate jump destinations. *)

(*val pc_inst_code : pc_inst -> byte*)
fun pc_inst_code  :: " pc_inst \<Rightarrow> 8 word "  where 
     " pc_inst_code JUMP = (((word_of_int 86) ::  8 word))"
|" pc_inst_code JUMPI = (((word_of_int 87) ::  8 word))"
|" pc_inst_code PC = (((word_of_int 88) ::  8 word))"
|" pc_inst_code JUMPDEST = (((word_of_int 91) ::  8 word))" 
declare pc_inst_code.simps [simp del]


datatype stack_inst =
    POP (* throwing away the topmost element of the stack *)
  | PUSH_N " byte list " (* pushing an element to the stack *)
  | CALLDATALOAD (* pushing a word to the stack, taken from the caller's data *)

(*val stack_inst_code : stack_inst -> list byte*)
fun stack_inst_code  :: " stack_inst \<Rightarrow>( 8 word)list "  where 
     " stack_inst_code POP = ( [((word_of_int 80) ::  8 word)])"
|" stack_inst_code (PUSH_N lst) = (
     if List.length lst <( 1 :: nat) then []
     else if List.length lst >( 32 :: nat) then []
     else [(byteFromNat (List.length lst) +((word_of_int 95) ::  8 word))] @ lst )"
|" stack_inst_code CALLDATALOAD = ( [((word_of_int 53) ::  8 word)])" 
declare stack_inst_code.simps [simp del]


type_synonym swap_inst =" byte "

(*val swap_inst_code : swap_inst -> maybe byte*)
definition swap_inst_code  :: " 8 word \<Rightarrow>( 8 word)option "  where 
     " swap_inst_code m = (
  if word_sless m(((word_of_int 1) ::  8 word)) then None else
  if word_sless (((word_of_int 16) ::  8 word)) m then None else
  Some (m +((word_of_int 143) ::  8 word)))"


datatype log_inst =
  LOG0
| LOG1
| LOG2
| LOG3
| LOG4

(*val log_inst_code : log_inst -> byte*)
fun log_inst_code  :: " log_inst \<Rightarrow> 8 word "  where 
     " log_inst_code LOG0 = (((word_of_int 160) ::  8 word))"
|" log_inst_code LOG1 = (((word_of_int 161) ::  8 word))"
|" log_inst_code LOG2 = (((word_of_int 162) ::  8 word))"
|" log_inst_code LOG3 = (((word_of_int 163) ::  8 word))"
|" log_inst_code LOG4 = (((word_of_int 164) ::  8 word))" 
declare log_inst_code.simps [simp del]


datatype misc_inst =
    STOP (* finishing the execution normally, with the empty return data *)
  | CREATE (* deploying some code in an account *)
  | CALL (* calling (i.e. sending a message to) an account *)
  | CALLCODE (* calling into this account, but the executed code can be some other account's *)
  | DELEGATECALL (* calling into this account, the executed code can be some other account's
                       but the sent value and the sent data are unchanged. *)
  | RETURN (* finishing the execution normally with data *)
  | SUICIDE (* send all remaining Eth balance to the specified account,
                  finishing the execution normally, and flagging the current account for deletion *)

(*val misc_inst_code : misc_inst -> byte*)
fun misc_inst_code  :: " misc_inst \<Rightarrow> 8 word "  where 
     " misc_inst_code STOP = (((word_of_int 0) ::  8 word))"
|" misc_inst_code CREATE = (((word_of_int 240) ::  8 word))"
|" misc_inst_code CALL = (((word_of_int 241) ::  8 word))"
|" misc_inst_code CALLCODE = (((word_of_int 242) ::  8 word))"
|" misc_inst_code RETURN = (((word_of_int 243) ::  8 word))"
|" misc_inst_code DELEGATECALL = (((word_of_int 244) ::  8 word))"
|" misc_inst_code SUICIDE = (((word_of_int 255) ::  8 word))" 
declare misc_inst_code.simps [simp del]


type_synonym annotation =" aenv \<Rightarrow> bool "

datatype inst =
    Unknown " byte "
  | Bits " bits_inst "
  | Sarith " sarith_inst "
  | Arith " arith_inst "
  | Info " info_inst "
  | Dup " dup_inst "
  | Memory " memory_inst "
  | Storage " storage_inst "
  | Pc " pc_inst "
  | Stack " stack_inst "
  | Swap " swap_inst "
  | Log " log_inst "
  | Misc " misc_inst "
  | Annotation " annotation "

fun maybe_to_list  :: " 'a option \<Rightarrow> 'a list "  where 
     " maybe_to_list None = ( [])"
|" maybe_to_list (Some s) = ( [s])" 
declare maybe_to_list.simps [simp del]


(*val inst_code : inst -> list byte*)
fun inst_code  :: " inst \<Rightarrow>( 8 word)list "  where 
     " inst_code (Unknown byte) = ( [byte])"
|" inst_code (Bits b) = ( [bits_inst_code b])"
|" inst_code (Sarith s) = ( [sarith_inst_code s])"
|" inst_code (Arith a) = ( [arith_inst_code a])"
|" inst_code (Info i) = ( [info_inst_code i])"
|" inst_code (Dup d) = ( maybe_to_list (dup_inst_code d))"
|" inst_code (Memory m) = ( [memory_inst_code m])"
|" inst_code (Storage s) = ( [storage_inst_code s])"
|" inst_code (Pc p) = ( [pc_inst_code p])"
|" inst_code (Stack s) = ( stack_inst_code s )"
|" inst_code (Swap s) = ( maybe_to_list (swap_inst_code s))"
|" inst_code (Log l) = ( [log_inst_code l])"
|" inst_code (Misc m) = ( [misc_inst_code m])"
|" inst_code (Annotation _) = ( [])" 
declare inst_code.simps [simp del]


(*val inst_size : inst -> nat*)
definition inst_size  :: " inst \<Rightarrow> nat "  where 
     " inst_size i = ( List.length (inst_code i))"


(*val drop_bytes : list inst -> nat -> list inst*)
fun  drop_bytes  :: "(inst)list \<Rightarrow> nat \<Rightarrow>(inst)list "  where 
     " drop_bytes prg n = ( (case  (prg, n) of
  (prg, 0) => prg
| (Stack (PUSH_N v) # rest, bytes) => drop_bytes rest ((bytes -( 1 :: nat)) - List.length v)
| (Annotation _ # rest, bytes) => drop_bytes rest bytes
| (_ # rest, bytes) => drop_bytes rest (bytes -( 1 :: nat))
| _ => []
))" 
declare drop_bytes.simps [simp del]


(*val program_size : list inst -> nat*)
fun  program_size  :: "(inst)list \<Rightarrow> nat "  where 
     " program_size (i # rest) = ( inst_size i + program_size rest )"
|" program_size ([]) = (( 0 :: nat))" 
declare program_size.simps [simp del]


(*val program_code : list inst -> list byte*)
fun  program_code  :: "(inst)list \<Rightarrow>( 8 word)list "  where 
     " program_code ([]) = ( [])"
|" program_code (inst # rest) = ( inst_code inst @ program_code rest )" 
declare program_code.simps [simp del]


record call_env = 

  callenv_gaslimit ::" uint " 
 (* the current block's gas limit *)
  callenv_value ::" uint " 
 (* the amount of Eth sent along*)
  callenv_data ::" byte list " 
 (* the data sent along *)
  callenv_caller ::" address " 
 (* the caller's address *)
  callenv_timestamp ::" uint " 
 (* the timestamp of the current block *)
  callenv_blocknum ::" uint " 
 (* the block number of the current block *)
  callenv_balance ::" address \<Rightarrow> uint "  (* the balances of all accounts. *)



record return_result = 

  return_data ::" byte list " 
 (* the returned data *)
  return_balance ::" address \<Rightarrow> uint " (* the balance of all accounts at the moment of the return*)



datatype world_action =
  WorldCall " call_env " (* the world calls into the account *)
| WorldRet " return_result " (* the world returns back to the account *)
| WorldFail (* the world fails back to the account. *)

record call_arguments = 

  callarg_gas ::" uint " 
 (* The portion of the remaining gas that the callee is allowed to use *)
  callarg_code ::" address " 
 (* The code that executes during the call *)
  callarg_recipient ::" address " 
 (* The recipient of the call, whose balance and the storage are modified. *)
  callarg_value ::" uint " 
 (* The amount of Eth sent along *)
  callarg_data ::" byte list " 
 (* The data sent along *)
  callarg_output_begin ::" uint " 
 (* The beginning of the memory region where the output data should be written. *)
  callarg_output_size ::" uint "  (* The size of the memory regions where the output data should be written. *)



record create_arguments = 

  createarg_value ::" uint " 
 (* The value sent to the account *)
  createarg_code ::" byte list "  (* The code that deploys the runtime code. *)



datatype contract_action =
  ContractCall " call_arguments " (* calling an account *)
| ContractCreate " create_arguments " (* deploying a smart contract *)
| ContractFail (* failing back to the caller *)
| ContractSuicide (* destroying itself and returning back to the caller *)
| ContractReturn " byte list " (* normally returning back to the caller *)

record program = 

  program_content ::" (nat, inst) Map.map " 
 (* a binary search tree that allows looking up instructions from positions *)
  program_length  ::" nat " 
 (* the length of the program in bytes *)
  program_annotation ::" nat \<Rightarrow> annotation list "  (* a mapping from positions to annotations *)



(*val store_byte_list_in_program : nat -> list byte -> map nat inst -> map nat inst*)
fun  store_byte_list_in_program  :: " nat \<Rightarrow>( 8 word)list \<Rightarrow>((nat),(inst))Map.map \<Rightarrow>((nat),(inst))Map.map "  where 
     " store_byte_list_in_program pos ([]) orig = ( orig )"
|" store_byte_list_in_program pos (h # t) orig = ( store_byte_list_in_program (pos +( 1 :: nat)) t (map_update pos (Unknown h) orig))" 
declare store_byte_list_in_program.simps [simp del]


(*val program_content_of_lst : nat -> list inst -> map nat inst*)
fun  program_content_of_lst  :: " nat \<Rightarrow>(inst)list \<Rightarrow>((nat),(inst))Map.map "  where 
     " program_content_of_lst pos ([]) = ( Map.empty )"
|" program_content_of_lst pos (Stack (PUSH_N bytes) # rest) = (
   store_byte_list_in_program (pos +( 1 :: nat)) bytes 
     (map_update pos (Stack (PUSH_N bytes))
          (program_content_of_lst ((pos +( 1 :: nat)) + List.length bytes) rest)))"
|" program_content_of_lst pos (Annotation _  # rest) = ( program_content_of_lst pos rest )"
|" program_content_of_lst pos (i # rest) = ( map_update pos i (program_content_of_lst (pos +( 1 :: nat)) rest))" 
declare program_content_of_lst.simps [simp del]


(*val prepend_annotation : nat -> annotation -> (nat -> list annotation) -> (nat -> list annotation)*)
definition prepend_annotation  :: " nat \<Rightarrow>(aenv \<Rightarrow> bool)\<Rightarrow>(nat \<Rightarrow>(aenv \<Rightarrow> bool)list)\<Rightarrow> nat \<Rightarrow>(aenv \<Rightarrow> bool)list "  where 
     " prepend_annotation pos annot orig p = ( if pos = p then annot # orig p else orig p )"


(*val program_annotation_of_lst : nat -> list inst -> nat -> list annotation*)
fun  program_annotation_of_lst  :: " nat \<Rightarrow>(inst)list \<Rightarrow> nat \<Rightarrow>(aenv \<Rightarrow> bool)list "  where 
     " program_annotation_of_lst pos ([]) = ( (\<lambda> _ .  []))"
|" program_annotation_of_lst pos (Annotation annot # rest) = ( prepend_annotation pos annot (program_annotation_of_lst pos rest))"
|" program_annotation_of_lst pos (i # rest) = ( program_annotation_of_lst (pos + inst_size i) rest )" 
declare program_annotation_of_lst.simps [simp del]


(*val program_of_lst : list inst -> program*)
definition program_of_lst  :: "(inst)list \<Rightarrow> program "  where 
     " program_of_lst lst = ( (|
  program_content = (program_content_of_lst(( 0 :: nat)) lst),
  program_length = (List.length lst),
  program_annotation = (program_annotation_of_lst(( 0 :: nat)) lst) 
|) )"


(*val program_as_memory : program -> memory*)
definition program_as_memory  :: " program \<Rightarrow> 256 word \<Rightarrow> 8 word "  where 
     " program_as_memory p idx = (
   (case  (program_content   p) (unat idx) of
     None =>((word_of_int 0) ::  8 word)
   | Some inst =>
      (case  index (inst_code inst)(( 0 :: nat)) of
        None =>((word_of_int 0) ::  8 word)
      | Some a => a
      )
   ))"


record block_info = 

  block_blockhash ::" uint \<Rightarrow> uint " 
 (* this captures the whole BLOCKHASH operation *)
  block_coinbase ::" address " 
 (* the miner who validates the block *)
  block_timestamp ::" uint " 

  block_number ::" uint " 
 (* the blocknumber of the block *)
  block_difficulty ::" uint " 

  block_gaslimit ::" uint " 
 (* the block gas imit *)
  block_gasprice ::" uint " 




record variable_env = 

  venv_stack ::" uint list " 

  venv_memory ::" memory " 

  venv_memory_usage ::" nat " 
 (* the current memory usage *)
  venv_storage ::" storage " 

  venv_pc ::" nat " 
 (* the program counter *)
  venv_balance ::" address \<Rightarrow> uint " 
 (* balances of all accounts *)
  venv_caller ::" address " 
 (* the caller's address *)
  venv_value_sent ::" uint " 
 (* the amount of Eth sent along the current invocation *)
  venv_data_sent ::" byte list " 
 (* the data sent along the current invocation *)
  venv_storage_at_call ::" storage " 
 (* the storage content at the invocation*)
  venv_balance_at_call ::" address \<Rightarrow> uint " 
 (* the balances at the invocation *)
  venv_origin ::" address " 
 (* the external account that started the current transaction *)
  venv_ext_program ::" address \<Rightarrow> program " 
 (* the codes of all accounts *)
  venv_block ::" block_info "  (* the current block *)



record constant_env = 

  cenv_program ::" program " 
 (* the code in the account under verification. *)
  cenv_this ::" address "  (* the address of the account under verification. *)



datatype instruction_result =
  InstructionContinue " variable_env " (* the execution should continue. *)
| InstructionAnnotationFailure (* the annotation turned out to be false. *)
| InstructionToWorld " contract_action " " storage " " (address \<Rightarrow> uint) " "  (variable_env * nat * nat)option " (* the variable environment to return to *)

(*val instruction_failure_result : variable_env -> instruction_result*)
definition instruction_failure_result  :: " variable_env \<Rightarrow> instruction_result "  where 
     " instruction_failure_result v = (
  InstructionToWorld ContractFail(venv_storage_at_call   v)(venv_balance_at_call   v) None )"


(*val instruction_return_result : list byte -> variable_env -> instruction_result*)
definition instruction_return_result  :: "(byte)list \<Rightarrow> variable_env \<Rightarrow> instruction_result "  where 
     " instruction_return_result x v = (
  InstructionToWorld (ContractReturn x)(venv_storage   v)(venv_balance   v) None )"


(*val gas : variable_env -> uint*)
definition gas  :: " variable_env \<Rightarrow> 256 word "  where 
     " gas _ = (((word_of_int 30000) ::  256 word))"


(*val M : nat -> uint -> uint -> nat*)
definition M  :: " nat \<Rightarrow> 256 word \<Rightarrow> 256 word \<Rightarrow> nat "  where 
     " M s f l = (
  if l =((word_of_int 0) ::  256 word) then s else max s (((unat f + unat l) +( 31 :: nat)) div( 32 :: nat)))"


(*val update_balance : address -> (uint -> uint) -> (address -> uint) -> (address -> uint)*)
definition update_balance  :: " 160 word \<Rightarrow>( 256 word \<Rightarrow> 256 word)\<Rightarrow>( 160 word \<Rightarrow> 256 word)\<Rightarrow> 160 word \<Rightarrow> 256 word "  where 
     " update_balance a f orig x = ( if x = a then f (orig a) else orig a )"


(*val venv_pop_stack : nat -> variable_env -> variable_env*)
fun  venv_pop_stack  :: " nat \<Rightarrow> variable_env \<Rightarrow> variable_env "  where 
     " venv_pop_stack n v = ( (case  (n,(venv_stack   v)) of
  (  (Suc n), _ # tl1) => venv_pop_stack n  v (| venv_stack := tl1 |)
| _ => v
))" 
declare venv_pop_stack.simps [simp del]


(*val venv_stack_top : variable_env -> maybe uint*)
definition venv_stack_top  :: " variable_env \<Rightarrow>( 256 word)option "  where 
     " venv_stack_top v = ( (case (venv_stack   v) of
   h # _ => Some h
 | [] => None
))"


(*val venv_update_storage : uint -> uint-> variable_env -> variable_env*)
definition venv_update_storage  :: " 256 word \<Rightarrow> 256 word \<Rightarrow> variable_env \<Rightarrow> variable_env "  where 
     " venv_update_storage idx vall v = (
   v (| venv_storage := (\<lambda> x .  if x = idx then vall else(venv_storage   v) x) |) )"


(*val venv_next_instruction : variable_env -> constant_env -> maybe inst*)
definition venv_next_instruction  :: " variable_env \<Rightarrow> constant_env \<Rightarrow>(inst)option "  where 
     " venv_next_instruction v c = ((program_content  (cenv_program  
   c))(venv_pc   v))"


(*val venv_advance_pc : constant_env -> variable_env -> variable_env*)
definition venv_advance_pc  :: " constant_env \<Rightarrow> variable_env \<Rightarrow> variable_env "  where 
     " venv_advance_pc c v = ( (case  venv_next_instruction v c of
   None =>  v (| venv_pc := ((venv_pc   v) +( 1 :: nat)) |)
 | Some inst =>  v (| venv_pc := ((venv_pc   v) + inst_size inst) |)
))"


(*val stack_0_0_op : variable_env -> constant_env -> instruction_result*)
definition stack_0_0_op  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " stack_0_0_op v c = ( InstructionContinue (venv_advance_pc c v))"


(*val stack_0_1_op : variable_env -> constant_env -> uint -> instruction_result*)
definition stack_0_1_op  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> 256 word \<Rightarrow> instruction_result "  where 
     " stack_0_1_op v c w = (
   InstructionContinue (venv_advance_pc c  v (| venv_stack := (w #(venv_stack   v)) |)))"



(*val stack_1_1_op : variable_env -> constant_env -> (uint -> uint) -> instruction_result*)
definition stack_1_1_op  :: " variable_env \<Rightarrow> constant_env \<Rightarrow>( 256 word \<Rightarrow> 256 word)\<Rightarrow> instruction_result "  where 
     " stack_1_1_op v c f = ( (case (venv_stack   v) of
    [] => instruction_failure_result v
  | h # t => InstructionContinue (venv_advance_pc c  v (| venv_stack := (f h # t) |))
))"


(*val stack_1_2_op : variable_env -> constant_env -> (uint -> uint * uint) -> instruction_result*)
definition stack_1_2_op  :: " variable_env \<Rightarrow> constant_env \<Rightarrow>( 256 word \<Rightarrow> 256 word* 256 word)\<Rightarrow> instruction_result "  where 
     " stack_1_2_op v c f = ( (case (venv_stack   v) of
   [] => instruction_failure_result v
 | h # t =>
     (let (new0, new1) = (f h) in
     InstructionContinue (venv_advance_pc c  v (| venv_stack := (new0 # (new1 # t)) |)))
))"


(*val stack_2_1_op : variable_env -> constant_env -> (uint -> uint -> uint) -> instruction_result*)
definition stack_2_1_op  :: " variable_env \<Rightarrow> constant_env \<Rightarrow>( 256 word \<Rightarrow> 256 word \<Rightarrow> 256 word)\<Rightarrow> instruction_result "  where 
     " stack_2_1_op v c f = ( (case (venv_stack   v) of
   operand0 # operand1 # rest =>
       InstructionContinue
         (venv_advance_pc c  v (| venv_stack := (f operand0 operand1 # rest) |))
  | _ => instruction_failure_result v
))"


(*val stack_3_1_op : variable_env -> constant_env -> (uint -> uint -> uint -> uint) -> instruction_result*)
definition stack_3_1_op  :: " variable_env \<Rightarrow> constant_env \<Rightarrow>( 256 word \<Rightarrow> 256 word \<Rightarrow> 256 word \<Rightarrow> 256 word)\<Rightarrow> instruction_result "  where 
     " stack_3_1_op v c f = ( (case (venv_stack   v) of
   operand0 # operand1 # operand2 # rest =>
       InstructionContinue
         (venv_advance_pc c  v (| venv_stack := (f operand0 operand1 operand2 # rest) |))
 | _ => instruction_failure_result v
))"


(*val sstore : variable_env -> constant_env -> instruction_result*)
definition sstore  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " sstore v c = ( (case (venv_stack   v) of
   addr # vl # stack_tail =>
      InstructionContinue (venv_advance_pc c
        (venv_update_storage addr vl  v (| venv_stack := stack_tail |)))
 | _ => instruction_failure_result v
))"


(*val build_aenv : variable_env -> constant_env -> aenv*)
definition build_aenv  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> aenv "  where 
     " build_aenv v c = ( (|
  aenv_stack = ((venv_stack   v)),
  aenv_memory = ((venv_memory   v)),
  aenv_storage = ((venv_storage   v)),
  aenv_balance = ((venv_balance   v)),
  aenv_caller = ((venv_caller   v)),
  aenv_value_sent = ((venv_value_sent   v)),
  aenv_data_sent = ((venv_data_sent   v)),
  aenv_storage_at_call = ((venv_storage_at_call   v)),
  aenv_balance_at_call = ((venv_balance_at_call   v)),
  aenv_this = ((cenv_this   c)),
  aenv_origin = ((venv_origin   v)) 
|) )"


(*val eval_annotation : annotation -> variable_env -> constant_env -> instruction_result*)
definition eval_annotation  :: "(aenv \<Rightarrow> bool)\<Rightarrow> variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " eval_annotation anno v c = (
   if anno (build_aenv v c) then InstructionContinue (venv_advance_pc c v)
    else InstructionAnnotationFailure )"


(*val jump : variable_env -> constant_env -> instruction_result*)
definition jump  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " jump v c = ( (case (venv_stack   v) of
   [] => instruction_failure_result v
 | pos # tl1 =>
     (let v_new = ( v (| venv_stack := tl1, venv_pc := (unat pos) |)) in
     (case  venv_next_instruction v_new c of
        Some (Pc JUMPDEST) => InstructionContinue v_new
      | _ => instruction_failure_result v
     ))
))"


(*val blockedInstructionContinue : variable_env -> bool -> instruction_result*)
definition blockedInstructionContinue  :: " variable_env \<Rightarrow> bool \<Rightarrow> instruction_result "  where 
     " blockedInstructionContinue v _ = ( InstructionContinue v )"


(*val blocked_jump : variable_env -> constant_env -> bool -> instruction_result*)
definition blocked_jump  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> bool \<Rightarrow> instruction_result "  where 
     " blocked_jump v c _ = ( jump v c )"


(*val strict_if : forall 'a. bool -> (bool -> 'a) -> (bool -> 'a) -> 'a*)
definition strict_if  :: " bool \<Rightarrow>(bool \<Rightarrow> 'a)\<Rightarrow>(bool \<Rightarrow> 'a)\<Rightarrow> 'a "  where 
     " strict_if b x y = ( if b then x True else y True )"


(*val jumpi : variable_env -> constant_env -> instruction_result*)
definition jumpi  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " jumpi v c = ( (case (venv_stack   v) of
   pos # cond # rest =>
    (let new_env = ( v (| venv_stack := (pos # rest) |)) in
    strict_if (cond =((word_of_int 0) ::  256 word))
           (blockedInstructionContinue (venv_advance_pc c (venv_pop_stack(( 2 :: nat)) v)))
           (blocked_jump new_env c))
 | _ => instruction_failure_result v
))"


(*val datasize : variable_env -> uint*)
definition datasize  :: " variable_env \<Rightarrow> 256 word "  where 
     " datasize v = ( word256FromNat (List.length(venv_data_sent   v)))"


(*val word_of_bytes : list byte -> uint*)
definition word_of_bytes  :: "( 8 word)list \<Rightarrow> 256 word "  where 
     " word_of_bytes lst = ( of_bl (List.concat (List.map to_bl lst)))"


(*val read_word_from_bytes : nat -> list byte -> uint*)
definition read_word_from_bytes  :: " nat \<Rightarrow>( 8 word)list \<Rightarrow> 256 word "  where 
     " read_word_from_bytes idx lst = ( word_of_bytes (List.take(( 32 :: nat)) (List.drop idx lst)))"


(*val cut_data : variable_env -> uint -> uint*)
definition cut_data  :: " variable_env \<Rightarrow> 256 word \<Rightarrow> 256 word "  where 
     " cut_data v idx = ( read_word_from_bytes (unat idx)(venv_data_sent   v))"


(*val cut_memory : uint -> nat -> (uint -> byte) -> list byte*)
fun  cut_memory  :: " 256 word \<Rightarrow> nat \<Rightarrow>( 256 word \<Rightarrow> 8 word)\<Rightarrow>( 8 word)list "  where 
     " cut_memory idx 0 memory = ( [])"
|" cut_memory idx (  (Suc n)) memory = ( memory idx # cut_memory (idx +((word_of_int 1) ::  256 word)) n memory )" 
declare cut_memory.simps [simp del]


(*val call : variable_env -> constant_env -> instruction_result*)
definition call  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " call v c = ( (case (venv_stack   v) of
   e0 # e1 # e2 # e3 # e4 # e5 # e6 # rest =>
     if word_sless ((venv_balance   v)(cenv_this   c)) e2 then instruction_failure_result v
     else
       InstructionToWorld (ContractCall
         (| callarg_gas = e0,
            callarg_code = (Word.ucast e1),
            callarg_recipient = (Word.ucast e1),
            callarg_value = e2,
            callarg_data = (cut_memory e3 (unat e4)(venv_memory   v)),
            callarg_output_begin = e5,
            callarg_output_size = e6 |))(venv_storage  
        v)
        (update_balance(cenv_this   c) (\<lambda> orig .  orig - e2)(venv_balance   v))
        (Some (* saving the variable environment for timing *)
          ( venv_advance_pc c v (|
           venv_stack := rest,
           venv_balance := (update_balance(cenv_this   c) (\<lambda> orig .  orig - e2)(venv_balance   v)),
           venv_memory_usage := (M (M(venv_memory_usage   v) e3 e4) e5 e6) |), absnat e5, absnat e6))
  | _ => instruction_failure_result v
))"


(*val delegatecall : variable_env -> constant_env -> instruction_result*)
definition delegatecall  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " delegatecall v c = ( (case (venv_stack   v) of
   e0 # e1 # e3 # e4 # e5 # e6 # rest =>
    if word_sless ((venv_balance   v)(cenv_this   c))(venv_value_sent   v) then instruction_failure_result v
     else
       InstructionToWorld
         (ContractCall
           (| callarg_gas = e0,
              callarg_code = (Word.ucast e1),
              callarg_recipient = (Word.ucast e1),
              callarg_value = ((venv_value_sent   v)),
              callarg_data = (cut_memory e3 (unat e4)(venv_memory   v)),
              callarg_output_begin = e5,
              callarg_output_size = e6 |))(venv_storage  
          v)(venv_balance   v)
          (Some (* save the variable environment for returns *)
            ( venv_advance_pc c v (| venv_stack := rest, venv_memory_usage := (M (M(venv_memory_usage   v) e3 e4) e5 e6) |), absnat e5, absnat e6))
  | _ => instruction_failure_result v
))"


(*val callcode : variable_env -> constant_env -> instruction_result*)
definition callcode  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " callcode v c = ( (case (venv_stack   v) of
   e0 # e1 # e2 # e3 # e4 # e5 # e6 # rest =>
    if word_sless ((venv_balance   v)(cenv_this   c)) e2 then
       instruction_failure_result v
     else
       InstructionToWorld
         (ContractCall
           (| callarg_gas = e0,
              callarg_code = (Word.ucast e1),
              callarg_recipient = ((cenv_this   c)),
              callarg_value = e2,
              callarg_data = (cut_memory e3 (unat e4)(venv_memory   v)),
              callarg_output_begin = e5,
              callarg_output_size = e6 |))(venv_storage  
          v)
          (update_balance(cenv_this   c) (\<lambda> orig .  orig - e2)(venv_balance   v))
          (Some (* saving the variable environment *)
            ( venv_advance_pc c v (|
                  venv_stack := rest,
                  venv_memory_usage := (M (M(venv_memory_usage   v) e3 e4) e5 e6),
                  venv_balance := (update_balance(cenv_this   c) (\<lambda> orig .  orig - e2)(venv_balance   v)) |), absnat e5, absnat e6))
  | _ => instruction_failure_result v
))"


(*val create : variable_env -> constant_env -> instruction_result*)
definition create  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " create v c = ( (case (venv_stack   v) of
    vl # code_start # code_len # rest =>
      if word_sless ((venv_balance   v)(cenv_this   c)) vl then instruction_failure_result v else
      (let code = (cut_memory code_start (unat code_len)(venv_memory   v)) in
      (let new_balance = (update_balance(cenv_this   c) (\<lambda> orig .  orig - vl)(venv_balance   v)) in
      InstructionToWorld
           (ContractCreate
             (| createarg_value = vl, createarg_code = code |))(venv_storage  
            v) new_balance
            (Some (* when returning to this invocation, use the following variable environment *)
              ( venv_advance_pc c v (| venv_stack := rest,
                 venv_balance := new_balance,
                 venv_memory_usage := (M(venv_memory_usage   v) code_start code_len) |),( 0 :: nat),( 0 :: nat)))))
  | _ => instruction_failure_result v
))"


definition venv_returned_bytes  :: " variable_env \<Rightarrow>( 8 word)list "  where 
     " venv_returned_bytes v = ( (case (venv_stack   v) of
   e0 # e1 # _ => cut_memory e0 (unat e1)(venv_memory   v)
 | _ => []
))"


(*val ret : variable_env -> constant_env -> instruction_result*)
definition ret  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " ret v _ = (  (case (venv_stack   v) of
   e0 # e1 # _ =>
     (let new_v = ( v (| venv_memory_usage := (M(venv_memory_usage   v) e0 e1) |)) in
     InstructionToWorld (ContractReturn (venv_returned_bytes new_v))(venv_storage  
                           v)(venv_balance   v)
                           None) (* No possibility of ever returning to this invocation. *)
 | _ => instruction_failure_result v
))"


(*val stop : variable_env -> constant_env -> instruction_result*)
definition stop  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " stop v _ = ( InstructionToWorld (ContractReturn [])(venv_storage   v)(venv_balance   v) None )"


(*val pop : variable_env -> constant_env -> instruction_result*)
definition pop  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " pop v c = ( (case (venv_stack   v) of
   _ # tl1 => InstructionContinue (venv_advance_pc c  v (| venv_stack := tl1 |))
 | [] => InstructionContinue (venv_advance_pc c v)
))"


(*val general_dup : nat -> variable_env -> constant_env -> instruction_result*)
definition general_dup  :: " nat \<Rightarrow> variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " general_dup n v c = ( (case  index(venv_stack   v) (n -( 1 :: nat)) of
    None => instruction_failure_result v
  | Some duplicated => InstructionContinue (venv_advance_pc c  v (| venv_stack := (duplicated #(venv_stack   v)) |))
))"


(*val store_byte_list_memory : uint -> list byte -> memory -> memory*)
function (sequential,domintros)  store_byte_list_memory  :: " 256 word \<Rightarrow>( 8 word)list \<Rightarrow>( 256 word \<Rightarrow> 8 word)\<Rightarrow> 256 word \<Rightarrow> 8 word "  where 
     " store_byte_list_memory pos ([]) orig = ( orig )"
|" store_byte_list_memory pos (h # t) orig = (
     store_byte_list_memory (pos +((word_of_int 1) ::  256 word)) t (\<lambda> p .  if pos = p then h else orig p))" 
by pat_completeness auto


(*val store_word_memory : uint -> uint -> memory -> memory*)
definition store_word_memory  :: " 256 word \<Rightarrow> 256 word \<Rightarrow>(uint \<Rightarrow> byte)\<Rightarrow> uint \<Rightarrow> byte "  where 
     " store_word_memory pos vl mem = (
   store_byte_list_memory pos (word_rsplit vl) mem )"


(*val mstore : variable_env -> constant_env -> instruction_result*)
definition mstore  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " mstore v c = ( (case (venv_stack   v) of
    pos # vl # rest =>
       (let new_memory = (store_word_memory pos vl(venv_memory   v)) in
       InstructionContinue (venv_advance_pc c
          v (| venv_stack := rest, venv_memory := new_memory,
           venv_memory_usage := (M(venv_memory_usage   v) pos(((word_of_int 32) ::  256 word)))
          |)))
  | _ => instruction_failure_result v
))"


(*val mload : variable_env -> constant_env -> instruction_result*)
definition mload  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " mload v c = ( (case (venv_stack   v) of
   pos # rest =>
      (let value1 = (read_word_from_bytes(( 0 :: nat)) (cut_memory pos(( 32 :: nat))(venv_memory   v))) in
      InstructionContinue (venv_advance_pc c  v (| venv_stack := (value1 # rest), venv_memory_usage := (M(venv_memory_usage   v) pos(((word_of_int 32) ::  256 word))) |)))
 | _ => instruction_failure_result v
))"


(*val mstore8 : variable_env -> constant_env -> instruction_result*)
definition mstore8  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " mstore8 v c = ( (case (venv_stack   v) of
   pos # vl # rest =>
   (let new_memory = (\<lambda> p .  if p = pos then Word.ucast vl else(venv_memory   v) p) in
   InstructionContinue (venv_advance_pc c
           v (| venv_stack := rest, venv_memory_usage := (M(venv_memory_usage   v) pos(((word_of_int 8) ::  256 word))),
                    venv_memory := new_memory |)))
 | _ => instruction_failure_result v
))"


(*val input_as_memory : list byte -> memory*)
definition input_as_memory  :: "( 8 word)list \<Rightarrow> 256 word \<Rightarrow> 8 word "  where 
     " input_as_memory lst idx = ( (case  index lst (absnat idx) of
   None =>((word_of_int 0) ::  8 word)
 | Some a => a
))"


(*val calldatacopy : variable_env -> constant_env -> instruction_result*)
definition calldatacopy  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " calldatacopy v c = ( (case (venv_stack   v) of
   dst_start # src_start # len # rest =>
       (let data = (cut_memory src_start (absnat len) (input_as_memory(venv_data_sent   v))) in
       (let new_memory = (store_byte_list_memory dst_start data(venv_memory   v)) in
       InstructionContinue (venv_advance_pc c
          v (| venv_stack := rest, venv_memory := new_memory,
            venv_memory_usage := (M(venv_memory_usage   v) dst_start len) |))))
 | _ => instruction_failure_result v
))"


(*val codecopy : variable_env -> constant_env -> instruction_result*)
definition codecopy  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " codecopy v c = ( (case (venv_stack   v) of
   dst_start # src_start # len # rest =>
     (let data = (cut_memory src_start (absnat len)
                  (program_as_memory(cenv_program   c))) in
     (let new_memory = (store_byte_list_memory dst_start data(venv_memory   v)) in
     InstructionContinue (venv_advance_pc c
        v (| venv_stack := rest, venv_memory := new_memory,
                 venv_memory_usage := (M(venv_memory_usage   v) dst_start len) |))))
 | _ => instruction_failure_result v
))"


(*val extcodecopy : variable_env -> constant_env -> instruction_result*)
definition extcodecopy  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " extcodecopy v c = ( (case (venv_stack   v) of
   addr # dst_start # src_start # len # rest =>
     (let data = (cut_memory src_start (absnat len)
                  (program_as_memory
                    ((venv_ext_program   v) (Word.ucast addr)))) in
     (let new_memory = (store_byte_list_memory dst_start data(venv_memory   v)) in
     InstructionContinue (venv_advance_pc c
        v (| venv_stack := rest, venv_memory := new_memory,
                 venv_memory_usage := (M(venv_memory_usage   v) dst_start len) |))))
 | _ => instruction_failure_result v
))"


(*val pc : variable_env -> constant_env -> instruction_result*)
definition pc  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " pc v c = (
   InstructionContinue (venv_advance_pc c
      v (| venv_stack := (word256FromNat(venv_pc   v) #(venv_stack   v))|)))"


(*val log : nat -> variable_env -> constant_env -> instruction_result*)
definition log  :: " nat \<Rightarrow> variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " log n v c = (
   InstructionContinue (venv_advance_pc c (venv_pop_stack (n+( 2 :: nat)) v)))"


(*val list_swap : forall 'a. nat -> list 'a -> maybe (list 'a)*)
definition list_swap  :: " nat \<Rightarrow> 'a list \<Rightarrow>('a list)option "  where 
     " list_swap n lst = ( (case  (index lst n, index lst(( 0 :: nat))) of
   (Some n_th, Some first1) => Some (List.concat [[n_th], List.take (n -( 1 :: nat)) (List.drop(( 1 :: nat)) lst), [first1], List.drop (( 1 :: nat) + n) lst])
 | _ => None
))"


(*val swap : nat -> variable_env -> constant_env -> instruction_result*)
definition swap  :: " nat \<Rightarrow> variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " swap n v c = ( (case  list_swap n(venv_stack   v) of
   None => instruction_failure_result v
 | Some new_stack => InstructionContinue (venv_advance_pc c  v (| venv_stack := new_stack |))
))"


(*val sha3 : variable_env -> constant_env -> instruction_result*)
definition sha3  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " sha3 v c = ( (case (venv_stack   v) of
   start # len # rest =>
      InstructionContinue (
        venv_advance_pc c  v (| venv_stack := (keccac (cut_memory start (unat len)(venv_memory   v)) # rest),
                                    venv_memory_usage := (M(venv_memory_usage   v) start len) |))
 | _ => instruction_failure_result v
))"


(*val suicide : variable_env -> constant_env -> instruction_result*)
definition suicide  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> instruction_result "  where 
     " suicide v c = ( (case (venv_stack   v) of
   dst # _ => (let new_balance = (\<lambda> addr . 
                     if addr = (cenv_this   c) then
                       ((word_of_int 0) :: 256 word) else
                       if addr = Word.ucast dst then
                         (venv_balance   v) (cenv_this   c) +
                           (venv_balance   v) addr else
                         (venv_balance   v) addr) in
 InstructionToWorld ContractSuicide (venv_storage   v) new_balance None)
 | _ => instruction_failure_result v
))"


(*val instruction_sem : variable_env -> constant_env -> inst -> instruction_result*)
fun instruction_sem  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> inst \<Rightarrow> instruction_result "  where 
     " instruction_sem v c (Stack (PUSH_N lst)) = ( stack_0_1_op v c (word_of_bytes lst))"
|" instruction_sem v c (Unknown _) = ( instruction_failure_result v )"
|" instruction_sem v c (Storage SLOAD) = ( stack_1_1_op v c(venv_storage   v))"
|" instruction_sem v c (Storage SSTORE) = ( sstore v c )"
|" instruction_sem v c (Pc JUMPI) = ( jumpi v c )"
|" instruction_sem v c (Pc JUMP) = ( jump v c )"
|" instruction_sem v c (Pc JUMPDEST) = ( stack_0_0_op v c )"
|" instruction_sem v c (Info CALLDATASIZE) = ( stack_0_1_op v c (datasize v))"
|" instruction_sem v c (Stack CALLDATALOAD) = ( stack_1_1_op v c (cut_data v))"
|" instruction_sem v c (Info CALLER) = ( stack_0_1_op v c (Word.ucast(venv_caller   v)))"
|" instruction_sem v c (Arith ADD) = ( stack_2_1_op v c (\<lambda> a b .  a + b))"
|" instruction_sem v c (Arith SUB) = ( stack_2_1_op v c (\<lambda> a b .  a - b))"
|" instruction_sem v c (Arith ISZERO) = ( stack_1_1_op v c (\<lambda> a .  if a =((word_of_int 0) ::  256 word) then((word_of_int 1) ::  256 word) else((word_of_int 0) ::  256 word)))"
|" instruction_sem v c (Misc CALL) = ( call v c )"
|" instruction_sem v c (Misc RETURN) = ( ret v c )"
|" instruction_sem v c (Misc STOP) = ( stop v c )"
|" instruction_sem v c (Dup n) = ( general_dup (unat n) v c )"
|" instruction_sem v c (Stack POP) = ( pop v c )"
|" instruction_sem v c (Info GASLIMIT) = ( stack_0_1_op v c(block_gaslimit  (venv_block   v)))"
|" instruction_sem v c (Arith inst_GT) = ( stack_2_1_op v c (\<lambda> a b .  if a > b then((word_of_int 1) ::  256 word) else((word_of_int 0) ::  256 word)))"
|" instruction_sem v c (Arith inst_EQ) = ( stack_2_1_op v c (\<lambda> a b .  if a = b then((word_of_int 1) ::  256 word) else((word_of_int 0) ::  256 word)))"
|" instruction_sem v c (Annotation a) = ( eval_annotation a v c )"
|" instruction_sem v c (Bits inst_AND) = ( stack_2_1_op v c (\<lambda> a b .  a AND b))"
|" instruction_sem v c (Bits inst_OR) = ( stack_2_1_op v c (\<lambda> a b .  a OR b))"
|" instruction_sem v c (Bits inst_XOR) = ( stack_2_1_op v c (\<lambda> a b .  a XOR b))"
|" instruction_sem v c (Bits inst_NOT) = ( stack_1_1_op v c (\<lambda> a .  - a))"
|" instruction_sem v c (Bits BYTE) = (
    stack_2_1_op v c get_byte )"
|" instruction_sem v c (Sarith SDIV) = ( stack_2_1_op v c
     (\<lambda> n divisor .  if divisor =((word_of_int 0) ::  256 word) then((word_of_int 0) ::  256 word) else
                        word_of_int ((sintFromW256 n) div (sintFromW256 divisor))))"
|" instruction_sem v c (Sarith SMOD) = ( stack_2_1_op v c
     (\<lambda> n divisor .  if divisor =((word_of_int 0) ::  256 word) then((word_of_int 0) ::  256 word) else
                       word_of_int ((sintFromW256 n) mod (sintFromW256 divisor))))"
|" instruction_sem v c (Sarith SGT) = ( stack_2_1_op v c
     (\<lambda> elm0 elm1 .  if word_sless elm1 elm0 then((word_of_int 1) ::  256 word) else((word_of_int 0) ::  256 word)))"
|" instruction_sem v c (Sarith SLT) = ( stack_2_1_op v c
     (\<lambda> elm0 elm1 .  if word_sless elm0 elm1 then((word_of_int 1) ::  256 word) else((word_of_int 0) ::  256 word)))"
|" instruction_sem v c (Sarith SIGNEXTEND) = ( stack_2_1_op v c
     (\<lambda> len orig . 
        uint_of_bl (List.map (\<lambda> i . 
          if i \<le>(( 256 :: int) -(( 8 :: int) * (uint len +( 1 :: int))))
          then test_bit orig (nat (abs (( 256 :: int) -(( 8 :: int) * (uint len +( 1 :: int))))))
          else test_bit orig (nat (abs i))
        ) (genlist (\<lambda> x .  int x)(( 256 :: nat))))
     ))"
|" instruction_sem v c (Arith MUL) = ( stack_2_1_op v c
     (\<lambda> a b .  a * b))"
|" instruction_sem v c (Arith DIV) = ( stack_2_1_op v c
     (\<lambda> a divisor .  (if divisor =((word_of_int 0) ::  256 word) then((word_of_int 0) ::  256 word) else a div divisor)))"
|" instruction_sem v c (Arith MOD) = ( stack_2_1_op v c
     (\<lambda> a divisor .  (if divisor =((word_of_int 0) ::  256 word) then((word_of_int 0) ::  256 word) else a mod divisor)))"
|" instruction_sem v c (Arith ADDMOD) = ( stack_3_1_op v c
     (\<lambda> a b divisor . 
         (if divisor =((word_of_int 0) ::  256 word) then((word_of_int 0) ::  256 word) else (a + b) mod divisor)))"
|" instruction_sem v c (Arith MULMOD) = ( stack_3_1_op v c
     (\<lambda> a b divisor . 
         (if divisor =((word_of_int 0) ::  256 word) then((word_of_int 0) ::  256 word) else (a * b) mod divisor)))"
|" instruction_sem v c (Arith EXP) = ( stack_2_1_op v c (\<lambda> a exponent .  word_of_int (uint a ^ unat exponent)))"
|" instruction_sem v c (Arith inst_LT) = ( stack_2_1_op v c (\<lambda> arg0 arg1 .  if word_sless arg0 arg1 then((word_of_int 1) ::  256 word) else((word_of_int 0) ::  256 word)))"
|" instruction_sem v c (Arith SHA3) = ( sha3 v c )"
|" instruction_sem v c (Info ADDRESS) = ( stack_0_1_op v c (Word.ucast(cenv_this   c)))"
|" instruction_sem v c (Info BALANCE) = ( stack_1_1_op v c (\<lambda> addr . (venv_balance   v) (Word.ucast addr)))"
|" instruction_sem v c (Info ORIGIN) = ( stack_0_1_op v c (Word.ucast(venv_origin   v)))"
|" instruction_sem v c (Info CALLVALUE) = ( stack_0_1_op v c(venv_value_sent   v))"
|" instruction_sem v c (Info CODESIZE) = ( stack_0_1_op v c (word256FromNat(program_length  (cenv_program   c))))"
|" instruction_sem v c (Info GASPRICE) = ( stack_0_1_op v c(block_gasprice  (venv_block   v)))"
|" instruction_sem v c (Info EXTCODESIZE) = ( stack_1_1_op v c
     (\<lambda> arg .  word256FromNat(program_length   ((venv_ext_program   v) (Word.ucast arg)))))"
|" instruction_sem v c (Info BLOCKHASH) = ( stack_1_1_op v c(block_blockhash  (venv_block   v)))"
|" instruction_sem v c (Info COINBASE) = ( stack_0_1_op v c (Word.ucast(block_coinbase  (venv_block   v))))"
|" instruction_sem v c (Info TIMESTAMP) = ( stack_0_1_op v c(block_timestamp  (venv_block   v)))"
|" instruction_sem v c (Info NUMBER) = ( stack_0_1_op v c(block_number  (venv_block   v)))"
|" instruction_sem v c (Info DIFFICULTY) = ( stack_0_1_op v c(block_difficulty  (venv_block   v)))"
|" instruction_sem v c (Memory MLOAD) = ( mload v c )"
|" instruction_sem v c (Memory MSTORE) = ( mstore v c )"
|" instruction_sem v c (Memory MSTORE8) = ( mstore8 v c )"
|" instruction_sem v c (Memory CALLDATACOPY) = ( calldatacopy v c )"
|" instruction_sem v c (Memory CODECOPY) = ( codecopy v c )"
|" instruction_sem v c (Memory EXTCODECOPY) = ( extcodecopy v c )"
|" instruction_sem v c (Pc PC) = ( pc v c )"
|" instruction_sem v c (Log LOG0) = ( log(( 0 :: nat)) v c )"
|" instruction_sem v c (Log LOG1) = ( log(( 1 :: nat)) v c )"
|" instruction_sem v c (Log LOG2) = ( log(( 2 :: nat)) v c )"
|" instruction_sem v c (Log LOG3) = ( log(( 3 :: nat)) v c )"
|" instruction_sem v c (Log LOG4) = ( log(( 4 :: nat)) v c )"
|" instruction_sem v c (Swap n) = ( swap (unat n) v c )"
|" instruction_sem v c (Misc CREATE) = ( create v c )"
|" instruction_sem v c (Misc CALLCODE) = ( callcode v c )"
|" instruction_sem v c (Misc SUICIDE) = ( suicide v c )"
|" instruction_sem v c (Misc DELEGATECALL) = ( delegatecall v c )"
|" instruction_sem v c (Info GAS) = ( stack_0_1_op v c (gas v))"
|" instruction_sem v c (Memory MSIZE) = ( stack_0_1_op v c (word256FromNat(venv_memory_usage   v)))" 
declare instruction_sem.simps [simp del]


datatype program_result =
  ProgramStepRunOut
| ProgramToWorld " contract_action " " storage " " (address \<Rightarrow> uint) " "  (variable_env * nat * nat)option "
| ProgramInvalid
| ProgramAnnotationFailure
| ProgramInit " call_env "

(*val check_annotations : variable_env -> constant_env -> bool*)
definition check_annotations  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> bool "  where 
     " check_annotations v c = (
  (let annots = ((program_annotation  (cenv_program   c))(venv_pc   v)) in
  ((\<forall> x \<in> (set annots).  (\<lambda> annot .  annot (build_aenv v c)) x))))"


(*val program_sem : variable_env -> constant_env -> nat -> nat -> program_result*)
(*val blocked_program_sem : variable_env -> constant_env -> nat -> nat -> bool -> program_result*)

fun  blocked_program_sem  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> bool \<Rightarrow> program_result "  
                   and program_sem  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> program_result "  where 
     " program_sem v c tiny_step 0 = ( ProgramStepRunOut )"
|" program_sem v c tiny_step (  (Suc remaining_steps)) = (
   if tiny_step \<le>( 0 :: nat) then
     ProgramToWorld ContractFail(venv_storage_at_call   v)(venv_balance_at_call   v) None else
   if \<not> (check_annotations v c) then ProgramAnnotationFailure else
   (case  venv_next_instruction v c of
      None => ProgramStepRunOut
    | Some i =>
      (case  instruction_sem v c i of
        InstructionContinue new_v =>
         (strict_if ((venv_pc   new_v) >(venv_pc   v))
           (blocked_program_sem new_v c (tiny_step -( 1 :: nat)) (remaining_steps+( 1 :: nat)))
           (blocked_program_sem new_v c(program_length  (cenv_program   c)) remaining_steps))
      | InstructionToWorld a st bal opt_pushed_v => ProgramToWorld a st bal opt_pushed_v
      | _ => ProgramInvalid
      )
   ))" |" blocked_program_sem v c l p _ = ( program_sem v c l p )" 
declare program_sem.simps [simp del]


(*val program_sem_blocked : variable_env -> constant_env -> nat -> nat -> bool -> program_result*)
definition program_sem_blocked  :: " variable_env \<Rightarrow> constant_env \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> bool \<Rightarrow> program_result "  where 
     " program_sem_blocked v c internal external _ = ( program_sem v c internal external )"


record account_state = 

  account_address ::" address " 

  account_storage ::" storage " 

  account_code ::" program " 

  account_balance ::" uint " 

  account_ongoing_calls ::" (variable_env * nat * nat) list " 

  account_killed ::" bool " 



(*val build_cenv : account_state -> constant_env*)
definition build_cenv  :: " account_state \<Rightarrow> constant_env "  where 
     " build_cenv a = (
  (| cenv_program = ((account_code   a)), cenv_this = ((account_address   a)) |) )"


(*val is_call_like : maybe inst -> bool*)
definition is_call_like  :: "(inst)option \<Rightarrow> bool "  where 
     " is_call_like i = ( ((i = Some (Misc CALL)) \<or> ((i = Some (Misc DELEGATECALL)) 
                 \<or> ((i = Some (Misc CALLCODE)) \<or> (i = Some (Misc CREATE))))))"


(*val build_venv_failed : account_state -> maybe variable_env*)
definition build_venv_failed  :: " account_state \<Rightarrow>(variable_env)option "  where 
     " build_venv_failed a = ( (case (account_ongoing_calls   a) of
   [] => None
 | (recovered,_,_) # _ =>
      if is_call_like ((program_content  (account_code   a)) ((venv_pc   recovered) -( 1 :: nat))) then
      Some ( recovered (| venv_stack :=(((word_of_int 0) ::  256 word) #(venv_stack   recovered)) |)) (* 0 is pushed, indicating failure*)
      else None
))"


(*val account_state_pop_ongoing_call : account_state -> account_state*)
definition account_state_pop_ongoing_call  :: " account_state \<Rightarrow> account_state "  where 
     " account_state_pop_ongoing_call orig = ( (case (account_ongoing_calls   orig) of
   _ # tl1 =>  orig (| account_ongoing_calls := tl1 |)
 | _ =>  orig (| account_ongoing_calls := ([]) |)
))"


(*val empty_program : program*)
definition empty_program  :: " program "  where 
     " empty_program = ( (|
  program_content = Map.empty,
  program_length =(( 0 :: nat)),
  program_annotation = (\<lambda> _ .  [])
|) )"


(*val empty_account : address -> account_state*)
definition empty_account  :: " 160 word \<Rightarrow> account_state "  where 
     " empty_account addr = (
 (| account_address = addr,
    account_storage = empty_storage,
   account_code = empty_program,
   account_balance =(((word_of_int 0) ::  256 word)),
   account_ongoing_calls = ([]),
   account_killed = False 
 |) )"


(*val update_account_state : account_state -> contract_action -> storage -> (address -> uint) -> maybe (variable_env*nat*nat) -> account_state*)
definition update_account_state  :: " account_state \<Rightarrow> contract_action \<Rightarrow>(uint \<Rightarrow> uint)\<Rightarrow>( 160 word \<Rightarrow> 256 word)\<Rightarrow>(variable_env*nat*nat)option \<Rightarrow> account_state "  where 
     " update_account_state prev act st bal v_opt = (
    prev (| 
     account_storage := st,
     account_balance := ((case  act of ContractFail =>(account_balance   prev)
                                   |  _ => bal(account_address   prev) )),
     account_ongoing_calls :=
                        ((case  v_opt of None =>(account_ongoing_calls   prev)
                                     | Some pushed => pushed #(account_ongoing_calls   prev) )),
     account_killed :=
       ((case  act of ContractSuicide => True
                  | _ =>(account_killed   prev) ))
    |) )"


type_synonym contract_behavior =" contract_action * (account_state \<Rightarrow> bool)"

record response_to_world = 

  when_called ::" call_env \<Rightarrow> contract_behavior " 

  when_returned ::" return_result \<Rightarrow> contract_behavior " 

  when_failed ::" contract_behavior " 



(*val empty_memory : memory*)
definition empty_memory  :: " 256 word \<Rightarrow> 8 word "  where 
     " empty_memory = ( (\<lambda> _ . ((word_of_int 0) ::  8 word)))"


inductive
    build_venv_called  :: " account_state \<Rightarrow> call_env \<Rightarrow> variable_env \<Rightarrow> bool "  where
  "venv_called" : " \<And> bal a env origin ext block.
    bal(account_address   a) =(account_balance   a) ==>
    build_venv_called a env
 (| venv_stack = ([]), (* The stack is initialized for every invocation *)
    venv_memory = empty_memory, (* The memory is also initialized for every invocation *)
     venv_memory_usage =(( 0 :: nat)), (* The memory usage is initialized. *)
     venv_storage = ((account_storage   a)), (* The storage is taken from the account state *)
     venv_pc =(( 0 :: nat)), (* The program counter is initialized to zero *)
     venv_balance = (\<lambda> (addr::address) .  if addr =(account_address   a) then bal(account_address   a) +(callenv_value   env) else bal addr), 
                        (* The balance is arbitrary, except that the balance of this account
                           is as specified in the account state plus the sent amount. *)
     venv_caller = ((callenv_caller   env)), (* the caller is specified by the world *)
     venv_value_sent = ((callenv_value   env)), (* the sent value is specified by the world *)
     venv_data_sent = ((callenv_data   env)), (* the sent data is specified by the world *)
     venv_storage_at_call = ((account_storage   a)), (* the snapshot of the storage is remembered in case of failure *)
     venv_balance_at_call = bal, (* the snapshot of the balance is remembered in case of failure *)
     venv_origin = origin, (* the origin of the transaction is arbitrarily chosen *)
     venv_ext_program = ext, (* the codes of the external programs are arbitrary. *)
     venv_block = block  (* the block information is chosen arbitrarily. *)
   |) "

(*val put_return_values : memory -> list byte -> nat -> nat -> memory*)
fun  put_return_values  :: "( 256 word \<Rightarrow> 8 word)\<Rightarrow>( 8 word)list \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> 256 word \<Rightarrow> 8 word "  where 
     " put_return_values orig lst b s = (
  if s \<le>( 0 :: nat) then orig else
  (case  lst of
    [] => orig
  | h # t => put_return_values (\<lambda> addr .  if addr = word256FromNat b then h else orig addr) t (b +( 1 :: nat)) (s -( 1 :: nat))
  ))" 
declare put_return_values.simps [simp del]


inductive (* the balance might have increased from the account state *)
  build_venv_returned  :: " account_state \<Rightarrow> return_result \<Rightarrow> variable_env \<Rightarrow> bool "  where
"venv_returned":
  " \<And> new_bal a_bal a_code v_pc a_addr a_storage v_stack v_memory v_memory_usage v_storage v_balance v_caller v_value v_data v_init_storage v_init_balance
         v_origin v_ext_program v_block mem_start mem_size  a_ongoing_rest a_killed r.
  is_call_like ((program_content   a_code) (v_pc -( 1 :: nat))) \<and> word_sle a_bal new_bal ==> (* the balance might have increased from the account state *)
  build_venv_returned
     (| account_address = a_addr,
       account_storage = a_storage,
       account_code = a_code,
       account_balance = a_bal,
       account_ongoing_calls =         
(((| venv_stack = v_stack,
          venv_memory = v_memory,
          venv_memory_usage = v_memory_usage,
          venv_storage = v_storage,
          venv_pc = v_pc,
          venv_balance = v_balance,
          venv_caller = v_caller,
          venv_value_sent = v_value,
          venv_data_sent = v_data,
          venv_storage_at_call = v_init_storage,
          venv_balance_at_call = v_init_balance,
          venv_origin = v_origin,
          venv_ext_program = v_ext_program,
          venv_block = v_block 
         |), mem_start, mem_size) # a_ongoing_rest),
       account_killed = a_killed
     |)
     r
     (|  venv_stack =(((word_of_int 1) ::  256 word) # v_stack), (* 1 is pushed, indicating a return *)
        venv_memory = (put_return_values v_memory(return_data   r) mem_start mem_size),
        venv_memory_usage = v_memory_usage,
        venv_storage = a_storage,
        venv_pc = v_pc,
        venv_balance = (update_balance a_addr
                            (\<lambda> _ .  new_bal)(return_balance   r)),
        venv_caller = v_caller,
        venv_value_sent = v_value,
        venv_data_sent = v_data,
        venv_storage_at_call = v_init_storage,
        venv_balance_at_call = v_init_balance,
        venv_origin = v_origin,
        venv_ext_program = v_ext_program,
        venv_block = v_block 
     |) "

(*val respond_to_call_correctly : (call_env -> contract_behavior) -> account_state -> bool*)
definition respond_to_call_correctly  :: "(call_env \<Rightarrow> contract_action*(account_state \<Rightarrow> bool))\<Rightarrow> account_state \<Rightarrow> bool "  where 
     " respond_to_call_correctly c a = (
  ((\<forall> call_env. \<forall> initial_venv. \<forall> resulting_action. \<forall> final_state_pred. 
     build_venv_called a call_env initial_venv \<longrightarrow>
         ((
         (* The specification says the execution should result in these *)c call_env = (resulting_action, final_state_pred)) \<longrightarrow>
         ((\<forall> steps.  (* and for any number of steps *)
           ( (let r = (program_sem initial_venv (build_cenv a)(program_length  (account_code   a)) steps) in             
(
             (* either more steps are necessary, or *)r = ProgramStepRunOut) \<or>
             (* the result matches the specification *)
             ((\<exists> pushed_venv. \<exists> st. \<exists> bal.               
(r = ProgramToWorld resulting_action st bal pushed_venv) \<and>
              final_state_pred
                (update_account_state a resulting_action st bal pushed_venv))))
           )))))))"


(*val respond_to_return_correctly : (return_result -> contract_behavior) -> account_state -> bool*)
definition respond_to_return_correctly  :: "(return_result \<Rightarrow> contract_action*(account_state \<Rightarrow> bool))\<Rightarrow> account_state \<Rightarrow> bool "  where 
     " respond_to_return_correctly r a = (
   ((\<forall> rr. \<forall> initial_venv. \<forall> final_state_pred. \<forall> resulting_action. 
       build_venv_returned a rr initial_venv \<longrightarrow>
       ((r rr = (resulting_action, final_state_pred)) \<longrightarrow>
       ((\<forall> steps. 
          ((let r = (program_sem initial_venv (build_cenv a)(program_length  (account_code   a)) steps) in           
(r = ProgramStepRunOut) \<or>
           ((\<exists> pushed_venv. \<exists> st. \<exists> bal.             
(r = ProgramToWorld resulting_action st bal pushed_venv) \<and>
            final_state_pred
              (update_account_state (account_state_pop_ongoing_call a) resulting_action st bal pushed_venv))))
          )))))))"


(*val respond_to_fail_correctly : contract_behavior -> account_state -> bool*)
definition respond_to_fail_correctly  :: " contract_action*(account_state \<Rightarrow> bool)\<Rightarrow> account_state \<Rightarrow> bool "  where 
     " respond_to_fail_correctly f a = (
   ((\<forall> initial_venv. \<forall> final_state_pred. \<forall> resulting_action.       
(Some initial_venv = build_venv_failed a) \<longrightarrow>
      ((f = (resulting_action, final_state_pred)) \<longrightarrow>
      ((\<forall> steps. 
        ( (let r = (program_sem initial_venv (build_cenv a)(program_length  (account_code   a)) steps) in          
(r = ProgramStepRunOut) \<or>
          ((\<exists> pushed_venv. \<exists> st. \<exists> bal.              
(r = ProgramToWorld resulting_action st bal pushed_venv) \<and>
             final_state_pred (update_account_state (account_state_pop_ongoing_call a) resulting_action st bal pushed_venv)))))))))))"


inductive
   account_state_responds_to_world  :: "(account_state \<Rightarrow> bool) \<Rightarrow> response_to_world \<Rightarrow> bool "  where
"AccountStep": " \<And> precond c r f.
  ((\<forall> a.  precond a \<longrightarrow> respond_to_call_correctly c a)) \<and>   
(((\<forall> a.  precond a \<longrightarrow> respond_to_return_correctly r a)) \<and>
   ((\<forall> a.  precond a \<longrightarrow> respond_to_fail_correctly f a))) ==>
   account_state_responds_to_world precond (| when_called = c, when_returned = r, when_failed = f |) "



end
