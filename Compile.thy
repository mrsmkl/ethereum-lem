chapter {* Generated by Lem from compile.lem. *}

theory "Compile" 

imports 
 	 Main
	 "Lem_pervasives" 
	 "Evm" 
	 "Word8" 
	 "Rlp" 

begin 

(*
  Copyright 2016 Sami MÃ¤kelÃ¤

   Licensed under the Apache License, Version 2.0 (the License);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an AS IS BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*)

(*open import Pervasives*)
(*open import Evm*)
(*open import Word8*)
(*open import Rlp*)

(*
let rec big_step c v = match v.venv_gas_left with
 | 0 -> ProgramStepRunOut
 | _ ->
   match venv_next_instruction v c with
    | Nothing -> ProgramStepRunOut
    | Just i ->
      match instruction_sem v c i with
      | InstructionContinue new_v -> big_step c new_v
      | InstructionToWorld a st bal opt_pushed_v -> ProgramToWorld a st bal opt_pushed_v
      | _ -> ProgramInvalid
      end
   end
end
*)

datatype program_state =
   Continue " variable_env " " nat " " nat "
 | Return " program_result "

(*val program_step : constant_env -> program_state -> program_state*)
fun program_step  :: " constant_env \<Rightarrow> program_state \<Rightarrow> program_state "  where 
     " program_step c (Continue v tiny_step remaining_steps) = (
  (case  remaining_steps of
    0 => Return ProgramStepRunOut
  |  (Suc remaining_steps) =>
   if tiny_step \<le>( 0 :: nat) then
     Return (ProgramToWorld ContractFail(venv_storage_at_call   v)(venv_balance_at_call   v) None) else
   if \<not> (check_annotations v c) then Return ProgramAnnotationFailure else
   (case  venv_next_instruction v c of
      None => Return ProgramStepRunOut
    | Some i =>
      (case  instruction_sem v c i of
        InstructionContinue new_v =>
         if(venv_pc   new_v) >(venv_pc   v) then Continue new_v (tiny_step -( 1 :: nat)) (remaining_steps+( 1 :: nat))
         else Continue new_v(program_length  (cenv_program   c)) remaining_steps
      | InstructionToWorld a st bal opt_pushed_v => Return (ProgramToWorld a st bal opt_pushed_v)
      | _ => Return ProgramInvalid
      )
   )
  ))"
|" program_step c (Return r) = ( Return r )" 
declare program_step.simps [simp del]


(*val program_iter : constant_env -> program_state -> nat -> program_state*)
fun  program_iter  :: " constant_env \<Rightarrow> program_state \<Rightarrow> nat \<Rightarrow> program_state "  where 
     " program_iter c st ((Suc n)) = ( program_iter c (program_step c st) n )"
|" program_iter c st 0 = ( st )" 
declare program_iter.simps [simp del]


(* expressions *)

datatype simple =
   ImmedV " uint "
(* | StackV of word8 *)
 | MemoryV " uint "
 | StorageV " uint "

fun get_simple  :: " variable_env \<Rightarrow> simple \<Rightarrow>( 256 word)option "  where 
     " get_simple v (ImmedV x) = ( Some x )"
|" get_simple v (MemoryV addr) = ( Some (read_word_from_bytes(( 0 :: nat)) (cut_memory addr(( 32 :: nat))(venv_memory   v))))"
|" get_simple v (StorageV addr) = ( Some ((venv_storage   v) addr))" 
declare get_simple.simps [simp del]


fun compile_simple  :: " simple \<Rightarrow>(inst)list "  where 
     " compile_simple (ImmedV uint1) = ( [Stack (PUSH_N (word_rsplit uint1))])"
|" compile_simple (MemoryV addr) = ( [Stack (PUSH_N (word_rsplit addr)), Memory MLOAD])"
|" compile_simple (StorageV addr) = ( [Stack (PUSH_N (word_rsplit addr)), Storage SLOAD])" 
declare compile_simple.simps [simp del]


fun get_stack_top  :: " program_result \<Rightarrow>( 256 word)option "  where 
     " get_stack_top ProgramStepRunOut = ( None )"
|" get_stack_top (ProgramToWorld c s f None) = ( None )"
|" get_stack_top (ProgramToWorld c s f(Some(v,n,n0))) = ( 
  (case ((venv_stack   v),n,n0,c,s,f) of
      ( top1 # _,_,_, _, _, _) => Some top1
    | (_,_,_,_,_,_) => None
  ) )"
|" get_stack_top ProgramInvalid = ( None )"
|" get_stack_top ProgramAnnotationFailure = ( None )"
|" get_stack_top (ProgramInit _) = ( None )" 
declare get_stack_top.simps [simp del]


definition eval_expr  :: " variable_env \<Rightarrow> 160 word \<Rightarrow>(inst)list \<Rightarrow>( 256 word)option "  where 
     " eval_expr v addr prog = (
  get_stack_top (program_sem ( v (| venv_pc :=(( 0 :: nat)) |)) (| cenv_program = (program_of_lst (prog @ [Misc STOP])), cenv_this = addr |)(( 100 :: nat))(( 100 :: nat))))"


datatype binop = Add | Minus

datatype unop = Negate | LNot

fun calc_unop  :: " 'a NumNegate_class \<Rightarrow> 'a WordNot_class \<Rightarrow> unop \<Rightarrow> 'a \<Rightarrow> 'a "  where 
     " calc_unop dict_Num_NumNegate_a dict_Word_WordNot_a Negate x = (
  (numNegate_method   dict_Num_NumNegate_a) x )"
|" calc_unop dict_Num_NumNegate_a dict_Word_WordNot_a LNot x = (
  (lnot_method   dict_Word_WordNot_a) x )" 
declare calc_unop.simps [simp del]


fun calc_binop  :: " 'a NumAdd_class \<Rightarrow> 'a NumMinus_class \<Rightarrow> binop \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a "  where 
     " calc_binop dict_Num_NumAdd_a dict_Num_NumMinus_a Add x y = (
  (numAdd_method   dict_Num_NumAdd_a) x y )"
|" calc_binop dict_Num_NumAdd_a dict_Num_NumMinus_a Minus x y = (
  (numMinus_method   dict_Num_NumMinus_a) x y )" 
declare calc_binop.simps [simp del]


fun lift_option  :: "('a \<Rightarrow> 'b)\<Rightarrow> 'a option \<Rightarrow> 'b option "  where 
     " lift_option f (Some x) = ( Some (f x))"
|" lift_option f None = ( None )" 
declare lift_option.simps [simp del]


definition lift_option2  :: "('b \<Rightarrow> 'a \<Rightarrow> 'c)\<Rightarrow> 'b option \<Rightarrow> 'a option \<Rightarrow> 'c option "  where 
     " lift_option2 f x y = ( (case  (x,y) of
   (Some x, Some y) => Some (f x y)
 | _ => None
))"


datatype expr =
   Simple " simple "
 | Binary " binop " " expr " " expr "
 | Unary " unop " " expr "

function (sequential,domintros)  get_expr  :: " variable_env \<Rightarrow> expr \<Rightarrow>( 256 word)option "  where 
     " get_expr v (Simple s) = ( get_simple v s )"
|" get_expr v (Unary op1 expr) = ( lift_option (calc_unop 
  Word256.instance_Num_NumNegate_Word256_word256_dict Word256.instance_Word_WordNot_Word256_word256_dict op1) (get_expr v expr))"
|" get_expr v (Binary op1 e1 e2) = ( lift_option2 (calc_binop 
  Word256.instance_Num_NumAdd_Word256_word256_dict Word256.instance_Num_NumMinus_Word256_word256_dict op1) (get_expr v e1) (get_expr v e2))" 
by pat_completeness auto


fun binop_inst  :: " binop \<Rightarrow>(inst)list "  where 
     " binop_inst Add = ( [Arith ADD])"
|" binop_inst Minus = ( [Arith SUB])" 
declare binop_inst.simps [simp del]


fun unop_inst  :: " unop \<Rightarrow>(inst)list "  where 
     " unop_inst Negate = ( compile_simple (ImmedV(((word_of_int 0) ::  256 word))) @ [Arith SUB])"
|" unop_inst LNot = ( [Bits inst_NOT])" 
declare unop_inst.simps [simp del]


function (sequential,domintros)  compile_expr  :: " expr \<Rightarrow>(inst)list "  where 
     " compile_expr (Simple s) = ( compile_simple s )"
|" compile_expr (Unary op1 expr) = ( compile_expr expr @ unop_inst op1 )"
|" compile_expr (Binary op1 e1 e2) = ( (compile_expr e1 @ compile_expr e2) @ binop_inst op1 )" 
by pat_completeness auto



end
