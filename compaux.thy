chapter {* Generated by Lem from compile.lem. *}

theory "compaux" 

imports 
 	 Main "~~/src/HOL/Library/Code_Target_Numeral"
	 "Lem_pervasives" 
	 "Evm" 
	 "Word8" 
	 "Rlp" 
	 "Compile" 

begin 


(****************************************************)
(*                                                  *)
(* Termination Proofs                               *)
(*                                                  *)
(****************************************************)

(*
termination big_step by lexicographic_order
*)

termination get_expr by lexicographic_order

termination compile_expr by lexicographic_order


(****************************************************)
(*                                                  *)
(* Lemmata                                          *)
(*                                                  *)
(****************************************************)

declare respond_to_call_correctly_def [simp]
declare respond_to_return_correctly_def [simp]
declare respond_to_fail_correctly_def [simp]
declare build_cenv_def [simp]
declare program_of_lst_def [simp]
declare build_venv_called.simps [simp]
declare eval_annotation_def [simp]

text {* The following lemma is just for controlling the Isabelle/HOL simplifier. *}

value "program_content_of_lst 0 always_fail_code"



(*
declare program_annotation_of_lst_def [simp]
*)


(*
declare store_byte_list_in_program.simps [simp]
*)

lemma foo  [cong] : "100 = Suc 99"
apply(auto)
done


declare program_sem.psimps [simp]
(*
declare program_sem.simps [simp]
*)
declare program_iter.simps [simp]
declare program_step.simps [simp]

theorem iter_return [simp] :
   "program_iter c (Return st) steps = Return st"
apply(induction steps)
apply(auto)
done

theorem iter_tinystep [simp] :
 " program_iter c (Continue v 0 (Suc k)) (Suc steps) =
  Return (program_sem v c 0 (Suc k))"
apply(subst program_sem.simps)
apply(auto)
done

theorem iter_annot [simp] :
 " \<not> check_annotations v c \<Longrightarrow>
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(subst program_sem.simps)
apply(auto)
done

theorem iter_no_next [simp] :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = None \<rbrakk> \<Longrightarrow>
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(subst program_sem.simps)
apply(auto)
done

theorem iter_inst_annotation [simp] :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = Some i;
    instruction_sem v c i = InstructionAnnotationFailure \<rbrakk> \<Longrightarrow>
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(subst program_sem.simps)
apply(auto)
done

theorem iter_inst_to_world [simp] :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = Some i;
    instruction_sem v c i = InstructionToWorld a st bal pushed_v \<rbrakk> \<Longrightarrow>
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(subst program_sem.simps)
apply(auto)
done

theorem iter_inst_continue1 [simp] :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = Some i;
    instruction_sem v c i = InstructionContinue new_v;
    venv_pc v < venv_pc new_v;
    \<forall>vv xx. (program_iter c (Continue vv n (Suc k)) steps =
         Return xx \<longrightarrow>
         program_iter c (Continue vv n (Suc k)) steps =
         Return (program_sem vv c n (Suc k)));
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
    Return x \<rbrakk> \<Longrightarrow>
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(subst program_sem.simps)
apply(auto)
apply(simp add: strict_if_def)
done

theorem iter_inst_continue2 [simp] :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = Some i;
    instruction_sem v c i = InstructionContinue new_v;
    venv_pc v \<ge> venv_pc new_v;
    \<forall>nn vv xx. (
         program_iter c (Continue vv nn k) steps = Return xx \<longrightarrow>
         program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k));
   program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) = Return x
   \<rbrakk> \<Longrightarrow>
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(subst program_sem.simps)
apply(auto)
apply(simp add: strict_if_def)
done

theorem iter_runout [simp] :
  "program_iter c (Continue v n 0) (Suc steps) =
   Return (program_sem v c n 0)"
apply(auto simp:program_sem.simps)
done

theorem step_foo : "\<exists>steps.
       program_iter c s1 (Suc steps) = s2 \<Longrightarrow>
\<exists>steps. program_iter c s1 steps = s2"
apply(blast)
done

theorem iter2_inst_continue1 [simp] :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = Some i;
    instruction_sem v c i = InstructionContinue new_v;
    venv_pc v < venv_pc new_v;
    \<forall>vv. \<exists>steps. program_iter c (Continue vv n (Suc k)) steps =
         Return (program_sem vv c n (Suc k))\<rbrakk> \<Longrightarrow>
  \<exists>steps. program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(subst program_sem.simps)
apply(auto)
apply(simp add: strict_if_def)
done

theorem iter2_inst_continue2 [simp] :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = Some i;
    instruction_sem v c i = InstructionContinue new_v;
    venv_pc v \<ge> venv_pc new_v;
    \<forall>vv nn. \<exists>steps. program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k)\<rbrakk> \<Longrightarrow>
  \<exists>steps. program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(subst program_sem.simps)
apply(auto)
apply(simp add: strict_if_def)
done

theorem iter2_inst_continue [simp] :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = Some i;
    instruction_sem v c i = InstructionContinue new_v;
    \<forall>vv. \<exists>steps. program_iter c (Continue vv n (Suc k)) steps =
         Return (program_sem vv c n (Suc k));
    \<forall>vv nn. \<exists>steps. program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k)\<rbrakk> \<Longrightarrow>
  \<exists>steps. program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(cases " venv_pc v < venv_pc new_v")
apply(rule iter2_inst_continue1)
apply(clarify)
apply(blast)
apply(blast)
apply(blast)
apply(blast)
apply(rule iter2_inst_continue2)
apply(blast)
apply(blast)
apply(blast)
apply(arith)
apply(blast)
done

declare program_iter.simps [simp del]
declare program_step.simps [simp del]

theorem iter_inst_continue :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = Some i;
    instruction_sem v c i = InstructionContinue new_v;
    \<forall>vv xx. (program_iter c (Continue vv n (Suc k)) steps = Return xx \<longrightarrow>
          program_iter c (Continue vv n (Suc k)) steps =
          Return (program_sem vv c n (Suc k)));
    \<forall>vv nn xx.
        ( program_iter c (Continue vv nn k) steps = Return xx \<longrightarrow>
          program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k) );
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) = Return x\<rbrakk> \<Longrightarrow>
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(cases " venv_pc v < venv_pc new_v")
apply(rule iter_inst_continue1)
apply(clarify)
apply(blast)
apply(blast)
apply(blast)
apply(blast)
apply(blast)
apply(rule iter_inst_continue2)
apply(blast)
apply(blast)
apply(blast)
apply(arith)
apply(blast)
apply(blast)
done

theorem iter_aux1 :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = Some i;
    \<forall>vv xx. (program_iter c (Continue vv n (Suc k)) steps = Return xx \<longrightarrow>
          program_iter c (Continue vv n (Suc k)) steps =
          Return (program_sem vv c n (Suc k)));
    \<forall>vv nn xx.
        ( program_iter c (Continue vv nn k) steps = Return xx \<longrightarrow>
          program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k) );
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) = Return x\<rbrakk> \<Longrightarrow>
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(cases "instruction_sem v c i")
apply(rule iter_inst_continue)
apply(blast)
apply(blast)
apply(blast)
apply(blast)
apply(blast)
apply(blast)
apply(auto)
done

theorem iter2_aux1 [simp] :
 "\<lbrakk> check_annotations v c;  venv_next_instruction v c = Some i;
    \<forall>vv. \<exists>steps. program_iter c (Continue vv n (Suc k)) steps =
         Return (program_sem vv c n (Suc k));
    \<forall>vv nn. \<exists>steps. program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k)\<rbrakk> \<Longrightarrow>
  \<exists>steps. program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(cases "instruction_sem v c i")
apply(rule iter2_inst_continue)
apply(blast)
apply(blast)
apply(blast)
apply(blast)
apply(blast)
apply(auto)
done

theorem iter_aux2 :
 "\<lbrakk> check_annotations v c;
    \<forall>vv xx. (program_iter c (Continue vv n (Suc k)) steps = Return xx \<longrightarrow>
          program_iter c (Continue vv n (Suc k)) steps =
          Return (program_sem vv c n (Suc k)));
    \<forall>vv nn xx.
        ( program_iter c (Continue vv nn k) steps = Return xx \<longrightarrow>
          program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k) );
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) = Return x\<rbrakk> \<Longrightarrow>
  
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(cases "venv_next_instruction v c")
defer
apply(rule iter_aux1)
apply(auto)
done

theorem iter2_aux2 [simp] :
 "\<lbrakk> check_annotations v c;
    \<forall>vv. \<exists>steps. program_iter c (Continue vv n (Suc k)) steps =
         Return (program_sem vv c n (Suc k));
    \<forall>vv nn. \<exists>steps. program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k)\<rbrakk> \<Longrightarrow>
  \<exists>steps. program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(cases "venv_next_instruction v c")
defer
apply(rule iter2_aux1)
apply(auto)
done

theorem iter_aux3 :
 "\<lbrakk> \<forall>vv xx. (program_iter c (Continue vv n (Suc k)) steps = Return xx \<longrightarrow>
          program_iter c (Continue vv n (Suc k)) steps =
          Return (program_sem vv c n (Suc k)));
    \<forall>vv nn xx.
        ( program_iter c (Continue vv nn k) steps = Return xx \<longrightarrow>
          program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k) );
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) = Return x\<rbrakk> \<Longrightarrow>
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(cases "check_annotations v c")
apply(rule iter_aux2)
apply(auto)
done

theorem iter2_aux3 [simp] :
 "\<lbrakk> \<forall>vv. \<exists>steps. program_iter c (Continue vv n (Suc k)) steps =
         Return (program_sem vv c n (Suc k));
    \<forall>vv nn. \<exists>steps. program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k)\<rbrakk> \<Longrightarrow>
  \<exists>steps. program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k))"
apply(cases "check_annotations v c")
apply(rule iter2_aux2)
apply(auto)
done

theorem iter2_aux4 [simp] :
 "\<lbrakk> \<forall>vv. \<exists>steps. program_iter c (Continue vv n (Suc k)) steps =
         Return (program_sem vv c n (Suc k));
    \<forall>vv nn. \<exists>steps. program_iter c (Continue vv nn k) steps =
         Return (program_sem vv c nn k)\<rbrakk> \<Longrightarrow>
  \<exists>steps. program_iter c (Continue v (Suc n) (Suc k)) steps =
  Return (program_sem v c (Suc n) (Suc k))"
apply(rule step_foo)
apply(rule iter2_aux3)
apply(auto)
done

definition iter_correct ::
   "variable_env \<Rightarrow> constant_env \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> bool" where
"iter_correct v c n k steps = (
   \<forall> x. Return x = program_iter c (Continue v n k) steps \<longrightarrow> 
        x = program_sem v c n k)"

definition iter_correct2 ::
   "variable_env \<Rightarrow> constant_env \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> bool" where
"iter_correct2 v c n k steps = (
   \<forall> x. program_iter c (Continue v n k) steps = Return x \<longrightarrow> 
        program_iter c (Continue v n k) steps =
        Return (program_sem v c n k))"

theorem correct_same : "iter_correct v c n k steps = iter_correct2 v c n k steps"
apply(auto simp:iter_correct_def simp:iter_correct2_def)
done

theorem ummm :
"\<forall>vv. iter_correct2 vv c n (Suc k) steps \<Longrightarrow>
    \<forall>vv nn. iter_correct2 vv c nn k steps \<Longrightarrow>
    \<forall>x. program_iter c
         (Continue v (Suc n) (Suc k))
         (Suc steps) =
        Return x \<Longrightarrow>
        program_iter c
         (Continue v (Suc n) (Suc k))
         (Suc steps) =
        Return (program_sem v c (Suc n) (Suc k))"
apply(rule iter_aux3)
apply(auto)
done

theorem lame : "Return x = Return y \<Longrightarrow> x = y"
apply(auto)
done

theorem lame2 :
 "program_iter c
          (Continue v (Suc n) (Suc k))
          (Suc steps) =
         Return x \<Longrightarrow>
  program_iter c (Continue v (Suc n) (Suc k)) (Suc steps) =
  Return (program_sem v c (Suc n) (Suc k)) \<Longrightarrow>
  x = program_sem v c (Suc n) (Suc k)"
apply(auto)
done

theorem iter_aux4 :
 "\<lbrakk> \<forall>vv. iter_correct vv c n (Suc k) steps;
    \<forall>vv nn. iter_correct vv c nn k steps \<rbrakk> \<Longrightarrow>
  iter_correct v c (Suc n) (Suc k) (Suc steps)"
apply(auto simp:correct_same)
apply(auto simp:iter_correct2_def)
apply(rule_tac steps = "steps" in lame2)
apply(blast)
apply(rule iter_aux3)
apply(auto)
done

theorem iter_nothing [simp] : "program_iter c st 0 = st"
apply(auto simp:program_iter.simps)
done

theorem blah1 [simp] : "Return x =
       program_iter c (Continue v n 0) steps \<Longrightarrow>
       program_sem v c n 0 = x"
apply(induction steps)
apply(auto)
done

theorem blah3 [simp] :
"(\<And>v n.
           iter_correct v c n (Suc k) steps) \<Longrightarrow>
       (\<And>v n x. iter_correct v c n k x) \<Longrightarrow>
       iter_correct v c n (Suc k) (Suc steps)"
apply(induction n arbitrary: v)
apply(subst iter_correct_def)
apply(auto)
apply(rule iter_aux4)
apply(auto)
done

theorem blah2 [simp] :
"(\<And>v n x. iter_correct v c n k x) \<Longrightarrow>
 iter_correct v c n (Suc k) steps"
apply(induction steps arbitrary: v n)
apply(subst iter_correct_def)
apply(auto)
done

theorem program_iter_bigstep :
"iter_correct v c n k steps"
(* Theorem: program_iter_bigstep*)(* try *)
apply(induction k arbitrary: v n steps)
apply(subst iter_correct_def)
apply(auto)
done

theorem iter_exists_aux [simp] :
"(\<And>v n.
           \<exists>steps.
              program_iter c (Continue v n k) steps =
              Return (program_sem v c n k)) \<Longrightarrow>
       \<exists>steps.
          program_iter c (Continue v n (Suc k)) steps =
          Return (program_sem v c n (Suc k))"
apply(induction n arbitrary:v k)
apply(rule_tac x = 1 in exI)
apply(simp add:program_iter.simps program_sem.simps program_step.simps)
apply(rule iter2_aux4)
defer
apply(blast)
apply(auto)
done

theorem iter_exists :
   "\<exists>steps. program_iter c (Continue v n k) steps = Return (program_sem v c n k)"
apply(induction k arbitrary:v n)
apply(rule_tac x = 1 in exI)
apply(auto)
done
(*
value "size (0::256 word)"

definition zurp :: "256 word \<Rightarrow> 256 word" where
"zurp k = k"

theorem foo3 [simp] : "size (w::256 word) = 256"
apply (auto simp:word_size)
done
*)

lemma strict_if_True [simp] :
"strict_if True a b = a True"
apply(simp add: strict_if_def)
done

text {* When the if-condition is known to be False, the simplifier
can proceed into the else-clause. *}

lemma strict_if_False [simp] :
"strict_if False a b = b True"
apply(simp add: strict_if_def)
done

text {* When the if-condition is not known to be either True or False,
the simplifier is allowed to perform computation on the if-condition. *}

lemma strict_if_cong [cong] :
"b0 = b1 \<Longrightarrow> strict_if b0 x y = strict_if b1 x y"
apply(auto)
done

lemma unblock_program_sem [simp] : "blocked_program_sem v c l p True = program_sem v c l p"
apply(simp add: blocked_program_sem.psimps)
done

lemma program_sem_unblock :
"program_sem_blocked v c internal external True = program_sem v c internal external"
apply(simp add: program_sem_blocked_def)
done


theorem foo2 : "length ((word_rsplit (w::256 word)) :: 8 word list) = 32"
apply(rule length_word_rsplit_even_size)
apply(auto simp:word_size)
done

theorem list_elems : "length lst = Suc x \<Longrightarrow>
 \<exists>b1 tl. lst = Cons b1 tl"
apply(induction lst)
apply(auto)
done

theorem list_elems1 : "length lst = 1 \<Longrightarrow> \<exists>b1. lst = [b1]"
apply(rule exE)
apply(rule list_elems)
apply(auto)
done

theorem list_elems2 : "length lst = 2 \<Longrightarrow> \<exists>b1 b2. lst = [b1,b2]"
apply(insert list_elems [of lst 1])
apply(auto)
apply(rule exE)
apply(rule list_elems)
apply(auto)
done

theorem list_elems3 : "length lst = 3 \<Longrightarrow> \<exists>b1 b2 b3. lst = [b1,b2,b3]"
apply(insert list_elems [of lst 2])
apply(auto)
apply(insert list_elems [of "drop 1 lst" 1])
apply(auto)
apply(insert list_elems [of "drop 2 lst" 0])
apply(auto)
done

theorem list_elems32 : "length lst = 32 \<Longrightarrow>
 \<exists>b1 b2 b3 b4 b5 b6 b7 b8 b9 b10
b11 b12 b13 b14 b15 b16 b17 b18 b19 b20
b21 b22 b23 b24 b25 b26 b27 b28 b29 b30 b31 b32.
 lst = [b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,
b11,b12,b13,b14,b15,b16,b17,b18,b19,b20,
b21,b22,b23,b24,b25,b26,b27,b28,b29,b30,b31,b32]"

apply(insert list_elems [of lst 31])
apply(auto)
apply(insert list_elems [of "drop 1 lst" 30])
apply(auto)
apply(insert list_elems [of "drop 2 lst" 29])
apply(auto)
apply(insert list_elems [of "drop 3 lst" 28])
apply(auto)
apply(insert list_elems [of "drop 4 lst" 27])
apply(auto)
apply(insert list_elems [of "drop 5 lst" 26])
apply(auto)
apply(insert list_elems [of "drop 6 lst" 25])
apply(auto)
apply(insert list_elems [of "drop 7 lst" 24])
apply(auto)
apply(insert list_elems [of "drop 8 lst" 23])
apply(auto)
apply(insert list_elems [of "drop 9 lst" 22])
apply(auto)
apply(insert list_elems [of "drop 10 lst" 21])
apply(auto)
apply(insert list_elems [of "drop 11 lst" 20])
apply(auto)
apply(insert list_elems [of "drop 12 lst" 19])
apply(auto)
apply(insert list_elems [of "drop 13 lst" 18])
apply(auto)
apply(insert list_elems [of "drop 14 lst" 17])
apply(auto)
apply(insert list_elems [of "drop 15 lst" 16])
apply(auto)
apply(insert list_elems [of "drop 16 lst" 15])
apply(auto)
apply(insert list_elems [of "drop 17 lst" 14])
apply(auto)
apply(insert list_elems [of "drop 18 lst" 13])
apply(auto)
apply(insert list_elems [of "drop 19 lst" 12])
apply(auto)
apply(insert list_elems [of "drop 20 lst" 11])
apply(auto)
apply(insert list_elems [of "drop 21 lst" 10])
apply(auto)
apply(insert list_elems [of "drop 22 lst" 9])
apply(auto)
apply(insert list_elems [of "drop 23 lst" 8])
apply(auto)
apply(insert list_elems [of "drop 24 lst" 7])
apply(auto)
apply(insert list_elems [of "drop 25 lst" 6])
apply(auto)
apply(insert list_elems [of "drop 26 lst" 5])
apply(auto)
apply(insert list_elems [of "drop 27 lst" 4])
apply(auto)
apply(insert list_elems [of "drop 28 lst" 3])
apply(auto)
apply(insert list_elems [of "drop 29 lst" 2])
apply(auto)
apply(insert list_elems [of "drop 30 lst" 1])
apply(auto)
apply(insert list_elems [of "drop 31 lst" 0])
apply(auto)
done

theorem word_elems32 : "\<exists>b1 b2 b3 b4 b5 b6 b7 b8 b9 b10
b11 b12 b13 b14 b15 b16 b17 b18 b19 b20
b21 b22 b23 b24 b25 b26 b27 b28 b29 b30 b31 b32.
 (word_rsplit (w::256 word) :: 8 word list) =
 [b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,
b11,b12,b13,b14,b15,b16,b17,b18,b19,b20,
b21,b22,b23,b24,b25,b26,b27,b28,b29,b30,b31,b32]"
apply(rule list_elems32)
apply(rule foo2)
done

fun get_foo :: "simple \<Rightarrow> 256 word" where
  "get_foo (Compile.ImmedV x) = x"
| "get_foo (Compile.MemoryV x) = x"
| "get_foo (Compile.StorageV x) = x"

declare check_annotations_def [simp]

declare program_content_of_lst.simps [simp]
declare store_byte_list_in_program.simps [simp]
declare program_annotation_of_lst.simps [simp]
declare prepend_annotation_def [simp]
declare inst_size_def [simp]
declare inst_code.simps [simp]
declare stack_inst_code.simps [simp]
declare venv_next_instruction_def [simp]
declare instruction_sem.simps [simp]
declare stack_0_1_op_def [simp]
declare venv_advance_pc_def [simp]
declare build_aenv_def [simp]
declare jump_def [simp]
(* declare word_of_bytes_def [simp] *)
declare instruction_failure_result_def [simp]
declare build_venv_returned.simps [simp]
declare build_venv_failed_def [simp]
declare compile_simple.simps [simp]
declare get_simple.simps [simp]
declare get_stack_top.simps [simp]

declare eval_expr_def [simp]
declare stop_def [simp]
declare mload_def [simp]
declare general_dup_def [simp]
declare stack_1_1_op_def [simp]

theorem simple_correct :
"( eval_expr v addr (compile_simple expr) = get_simple v expr)"
(* Theorem: simple_correct*)(* try *)
apply(insert word_elems32 [of "get_foo expr"])
apply(induction expr)
apply(auto)
apply(subst foo)
apply(subst foo)
apply(subst program_sem.simps)
apply(auto simp:foo2)
apply(subst foo)
apply(subst program_sem.simps)
apply(auto simp:foo2)
apply (metis word_rcat_rsplit)

apply(subst foo)
apply(subst foo)
apply(subst program_sem.simps)
apply(auto simp:foo2)
apply(subst foo)
apply(subst program_sem.simps)
apply(auto simp:foo2)
apply(subst foo)
apply(subst program_sem.simps)
apply(auto simp:foo2)
apply (metis word_rcat_rsplit)

apply(subst foo)
apply(subst foo)
apply(subst program_sem.simps)
apply(auto simp:foo2)
apply(subst foo)
apply(subst program_sem.simps)
apply(auto simp:foo2)
apply(subst foo)
apply(subst program_sem.simps)
apply(auto simp:foo2)
apply (metis word_rcat_rsplit)
done

fun get_stack_top2  :: " program_state \<Rightarrow>( 256 word)option "  where 
  " get_stack_top2 (Continue s _ _) = ( None )"
| " get_stack_top2 (Return a) = get_stack_top a"

definition make_prog :: "inst list \<Rightarrow> address \<Rightarrow> constant_env" where
"make_prog prog addr = (|
   cenv_program = (program_of_lst (prog @ [Misc STOP])),
   cenv_this = addr |)"

definition iter_expr  :: "nat \<Rightarrow> variable_env \<Rightarrow> 160 word \<Rightarrow>(inst)list \<Rightarrow>( 256 word)option "  where 
"iter_expr x v addr prog =
  get_stack_top2 (program_iter
      (make_prog prog addr)
      (Continue ( v (| venv_pc :=(( 0 :: nat)) |)) 0 0)
      x)"

theorem iter_add : 
  "program_iter c (program_iter c st y) x = program_iter c st (x+y)"
apply(induction y arbitrary: st x)
apply(auto simp:program_iter.simps)
done

theorem iter_suc :
 "program_iter c st (Suc x) = program_step c (program_iter c st x)"
apply(induction x arbitrary: st)
apply(auto simp:program_iter.simps)
done

theorem iter_return_stable :
  "program_iter c st x = Return rt \<Longrightarrow>
   program_iter c st (Suc x) = Return rt"
apply(induction x arbitrary:st)
apply(auto simp:program_iter.simps program_step.simps)
done

theorem last_iter_aux :
"(\<And>v a1 a2.
           program_iter c (Continue v a1 a2) x =
           Return rt \<Longrightarrow>
           \<exists>y nv e1 e2.
              program_iter c (Continue v a1 a2)
               y =
              Continue nv e1 e2 \<and>
              program_step c
               (Continue nv e1 e2) =
              Return rt) \<Longrightarrow>
       program_iter c (Continue v a1 a2)
        (Suc x) =
       Return rt \<Longrightarrow>
       \<exists>y nv e1 e2.
          program_iter c (Continue v a1 a2) y =
          Continue nv e1 e2 \<and>
          program_step c (Continue nv e1 e2) =
          Return rt"
apply(cases " program_iter c (Continue v a1 a2) x")
apply(simp add:iter_suc)
apply(blast)
apply(simp add:iter_return_stable)
done

theorem last_iter :
  "program_iter c (Continue v a1 a2) x = Return rt \<Longrightarrow>
  \<exists>y nv e1 e2. program_iter c (Continue v a1 a2) y = Continue nv e1 e2 \<and>
     program_step c (Continue nv e1 e2) = Return rt"
apply(induction x arbitrary: v a1 a2 )
apply(auto)
apply(rule last_iter_aux)
apply(auto)
done

fun maybe_eq :: "'a option \<Rightarrow> 'a option \<Rightarrow> bool" where
  "maybe_eq (Some a) (Some b) = (a = b)"
| "maybe_eq _ _ = True"

theorem expr_stop_aux2 :
   "program_sem (v\<lparr>venv_pc:=0\<rparr>) c 100 100 =
    ProgramStepRunOut \<Longrightarrow>
   get_stack_top (program_sem (v\<lparr>venv_pc:=0\<rparr>) c 100 100) = None"
apply(auto simp:make_prog_def)
done

declare program_sem.psimps [simp del]

theorem expr_stop_foo :
  "\<lbrakk> program_sem (v\<lparr>venv_pc:=0\<rparr>) c 100 100 =
    ProgramStepRunOut;
   get_stack_top (program_sem (v\<lparr>venv_pc:=0\<rparr>) c 100 100) = Some x
  \<rbrakk> \<Longrightarrow>
  False"
apply(auto)
done

theorem expr_stop_aux3 : 
  "get_stack_top (ProgramToWorld x21 x22 x23 t) = Some x \<Longrightarrow>
  \<exists>nv n k. t = Some (nv,n,k)"
apply(cases t)
apply(auto)
done

theorem expr_stop_aux :
  "eval_expr v addr code = Some res  \<Longrightarrow>
   \<exists>act stor bal nv n k. program_sem (v\<lparr> venv_pc := 0\<rparr>) (make_prog code addr) 100 100 =
    ProgramToWorld act stor bal (Some (nv, n, k))"
apply(simp add:make_prog_def)
apply(cases " program_sem (v\<lparr> venv_pc := 0\<rparr>)  \<lparr>cenv_program =
          \<lparr>program_content =
             program_content_of_lst 0
              (code @ [Misc STOP]),
             program_length = Suc (length code),
             program_annotation =
               program_annotation_of_lst 0
                (code @ [Misc STOP])\<rparr>,
          cenv_this = addr\<rparr> 100 100")
apply(auto)
apply(auto simp:expr_stop_aux3)
done

theorem expr_stop_aux11 :
  "\<exists>act stor bal nv n k. (eval_expr v addr code = Some res \<longrightarrow>
   program_sem (v\<lparr> venv_pc := 0\<rparr>) (make_prog code addr) 100 100 =
    ProgramToWorld act stor bal (Some (nv, n, k)))"
apply(auto simp:expr_stop_aux)
done

theorem iter_exists_foo :
 "program_sem v c n k = rt \<Longrightarrow>
  \<exists>x. program_iter c (Continue v n k) x = Return rt"
apply(auto simp:iter_exists)
done

theorem iter_exists_foo2 :
 "program_sem v c n k =
  ProgramToWorld act stor bal (Some (nv, n2, k2)) \<Longrightarrow>
  \<exists>x. program_iter c (Continue v n k) x =
      Return (ProgramToWorld act stor bal (Some (nv, n2, k2)))"
apply(auto simp:iter_exists_foo)
done

theorem iter_exists_foo3 :
  "\<exists>x. program_iter c (Continue v n k) x =
      Return (ProgramToWorld act stor bal (Some (nv, n2, k2)))
\<Longrightarrow> \<exists>act stor bal nv n2 k2 x. program_iter c (Continue v n k) x =
      Return (ProgramToWorld act stor bal (Some (nv, n2, k2)))"
apply(blast)
done

theorem iter_exists_foo4 :
"program_sem v c n k =
  ProgramToWorld act stor bal (Some (nv, n2, k2)) \<Longrightarrow>
 \<exists>act stor bal nv n2 k2 x. program_iter c (Continue v n k) x =
      Return (ProgramToWorld act stor bal (Some (nv, n2, k2)))"
apply(rule iter_exists_foo3)
apply(rule iter_exists_foo2)
apply(blast)
done

theorem iter_exists_foo5 :
"(\<exists>act stor bal nv n2 k2 x. program_sem v c n k =
  ProgramToWorld act stor bal (Some (nv, n2, k2))) \<longrightarrow>
 (\<exists>act stor bal nv n2 k2 x. program_iter c (Continue v n k) x =
      Return (ProgramToWorld act stor bal (Some (nv, n2, k2))))"
apply(auto simp:iter_exists_foo4)
done

declare expr_stop_aux [simp]

theorem expr_stop_aux4 :
  "eval_expr v addr (compile_expr expr) = Some res  \<Longrightarrow>
  \<exists>act stor bal nv n k x.
    program_iter (make_prog (compile_expr expr) addr)
      (Continue (v\<lparr>venv_pc:=0\<rparr>) 100 100) x =
    Return (ProgramToWorld act stor bal (Some (nv, n, k)))"
apply(auto simp:iter_exists_foo5)
done

fun simple_inst :: "inst \<Rightarrow> bool" where
  "simple_inst (Misc STOP) = False"
| "simple_inst (Misc RETURN) = False"
| "simple_inst (Misc CALL) = False"
| "simple_inst (Misc CREATE) = False"
| "simple_inst (Misc CALLCODE) = False"
| "simple_inst (Misc SUICIDE) = False"
| "simple_inst (Misc DELEGATECALL) = False"
| "simple_inst _ = True"

theorem compiled_simple_aux1 :
"xa \<in> set (compile_simple x) \<Longrightarrow> simple_inst xa"
apply(cases x)
apply(auto)
done

theorem compiled_simple_aux2 :
"x \<in> set (binop_inst x1a) \<Longrightarrow> simple_inst x"
apply(cases x1a)
apply(auto simp:binop_inst.simps)
done

theorem compiled_simple_aux3 :
"x \<in> set (unop_inst x1a) \<Longrightarrow> simple_inst x"
apply(cases x1a)
apply(auto simp:unop_inst.simps)
done

(* Compiled instructions are simple *)
theorem compiled_simple :
   "x \<in> set (compile_expr expr) \<Longrightarrow> simple_inst x"
apply(induction expr arbitrary:x)
apply(auto simp: compiled_simple_aux1 compiled_simple_aux2 compiled_simple_aux3)
done

(* Simple instructions do not return normally *)

fun will_return :: "inst option \<Rightarrow> bool" where
  "will_return (Some x) = (\<not> simple_inst x)"
| "will_return None = False"

theorem no_inst_error : "venv_next_instruction v c = None \<Longrightarrow>
  program_step c (Continue v n k) \<noteq>
   Return (ProgramToWorld act stor bal (Some (nv, n, k)))"
apply(auto simp:program_step.simps)
apply(cases k)
apply(auto)
apply(cases n)
apply(simp)
apply(cases "\<not> check_annotations v c")
apply(simp)
apply(cases "check_annotations v c")
defer
apply(blast)
apply (metis lame nat.distinct(1) option.simps(4) program_result.distinct(1) venv_next_instruction_def)
done

theorem name_1 :
   "check_annotations v c \<Longrightarrow> (\<not> check_annotations v c) = False"
apply(blast)
done

declare check_annotations_def [simp del]

theorem blahblah [simp] :
"stack_2_1_op v c x  \<noteq>
    InstructionToWorld act stor bal (Some (nv, n, k))"
apply(auto simp:stack_2_1_op_def)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
done

theorem blahblah2 [simp] :
"stack_1_1_op v c x  \<noteq>
    InstructionToWorld act stor bal (Some (nv, n, k))"
apply(auto simp:stack_2_1_op_def)
apply(cases "venv_stack v")
apply(auto)
done

theorem blahblah3 [simp] :
"stack_3_1_op v c x  \<noteq>
    InstructionToWorld act stor bal (Some (nv, n, k))"
apply(auto simp:stack_3_1_op_def)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
apply(cases "tl (tl (venv_stack v))")
apply(auto)
done

theorem no_return_bits :
  "instruction_sem v c (Bits x2) \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(cases x2)
apply(auto)
apply(cases "venv_stack v")
apply(auto)
done

theorem no_return_sarith :
  "instruction_sem v c (Sarith x2) \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(cases x2)
apply(auto)
done

theorem no_return_arith :
  "instruction_sem v c (Arith x2) \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(cases x2)
apply(auto simp:sha3_def)
apply(cases "venv_stack v")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
done

theorem no_return_info :
  "instruction_sem v c (Info x2) \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(cases x2)
apply(auto)
apply(cases "venv_stack v")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
done

theorem umpi_foo :
 "(if t then Continue x1 y1 z2 else Continue x2 y2 z2) =
       Return res
   \<Longrightarrow> False"
apply(cases t)
apply(auto)
done

theorem no_return_dup :
  "general_dup (unat x2) v c \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(auto)
apply(cases "index (venv_stack v) (unat x2 - Suc 0)")
apply(auto)
done

theorem umpi_umpi : "(if venv_pc v < venv_pc x1
        then Continue x1 (Suc (nata::nat) - 1) (nt + 1)
        else Continue x1
              (program_length (cenv_program c)) nt) =
       Return
        (ProgramToWorld act stor bal
          (Some (nv, Suc nata, Suc nt))) \<Longrightarrow> False"
apply(cases "venv_pc v < venv_pc x1")
apply(auto)
done

declare general_dup_def [simp del]

theorem no_return_memory :
  "instruction_sem v c (Memory i) \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(auto)
apply(cases i)
apply(auto simp:mstore_def mstore8_def calldatacopy_def
  codecopy_def extcodecopy_def)
apply(cases "venv_stack v")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
apply(cases "tl (tl (venv_stack v))")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
apply(cases "tl (tl (venv_stack v))")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
apply(cases "tl (tl (venv_stack v))")
apply(auto)
apply(cases "tl (tl (tl (venv_stack v)))")
apply(auto)
done

theorem no_return_storage :
  "instruction_sem v c (Storage i) \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(cases i)
apply(auto simp:sstore_def)
apply(cases "venv_stack v")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
done

fun get_some :: "'a option \<Rightarrow> 'a" where
"get_some (Some x) = x"

fun get_some_pc :: "inst option \<Rightarrow> pc_inst" where
"get_some_pc (Some (Pc x)) = x"


theorem no_return_blocked [simp] :
  "blockedInstructionContinue x z \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(auto simp:blockedInstructionContinue_def)
done


theorem no_return_blocked_jump [simp] :
  "blocked_jump v c z \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(auto simp:blocked_jump_def)
apply(cases "venv_stack v")
apply(auto)
apply(cases "program_content (cenv_program c)
                (unat (hd (venv_stack v)))")
apply(auto)
apply(cases "get_some (program_content (cenv_program c)
                (unat (hd (venv_stack v))))")
apply(auto)
apply(cases "get_some_pc (program_content (cenv_program c)
                (unat (hd (venv_stack v))))")
apply(auto)
done

theorem no_return_pc :
  "instruction_sem v c (Pc i) \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(cases i)
apply(auto simp:jumpi_def pc_def  stack_0_0_op_def)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
apply(cases "program_content (cenv_program c)
                (unat (hd (venv_stack v)))")
apply(auto)
apply(cases "get_some (program_content (cenv_program c)
                (unat (hd (venv_stack v))))")
apply(auto)
apply(cases "get_some_pc (program_content (cenv_program c)
                (unat (hd (venv_stack v))))")
apply(auto)
apply(cases "program_content (cenv_program c)
                (unat (hd (venv_stack v)))")
apply(auto)
apply(cases "get_some (program_content (cenv_program c)
                (unat (hd (venv_stack v))))")
apply(auto)
apply(cases "get_some_pc (program_content (cenv_program c)
                (unat (hd (venv_stack v))))")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
apply(cases "tl (venv_stack v)")
apply(auto)
apply(simp add:strict_if_def)
apply (metis blockedInstructionContinue_def instruction_result.simps(6) no_return_blocked_jump)
done

theorem no_return_stack :
  "instruction_sem v c (Stack i) \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(cases i)
apply(auto simp:pop_def)
apply(cases "venv_stack v")
apply(auto)
apply(cases "venv_stack v")
apply(auto)
done

theorem no_return_swap :
"swap x11 v c \<noteq>
       InstructionToWorld act stor bal
        (Some (nv, Suc nata, Suc nt))"
apply(auto simp:swap_def)
apply(cases "list_swap x11 (venv_stack v)")
apply(auto)
done

theorem no_return_misc :
  "simple_inst (Misc i) \<Longrightarrow>
   instruction_sem v c (Misc i) \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(cases i)
apply(auto simp:log_def)
done


theorem no_return_log :
  "instruction_sem v c (Log i) \<noteq>
   InstructionToWorld act stor bal (Some (nv,n,k))"
apply(cases i)
apply(auto simp:log_def)
done

theorem no_return_anno :
  "(if x then InstructionContinue (venv_advance_pc c v)
        else InstructionAnnotationFailure) \<noteq>
       InstructionToWorld act stor bal
        (Some (nv, Suc nata, Suc nt))"
apply(auto)
done

theorem no_simple_return :
 "\<lbrakk> venv_next_instruction v c = Some inst;
    simple_inst inst \<rbrakk>\<Longrightarrow>
  program_step c (Continue v n k) \<noteq>
   Return (ProgramToWorld act stor bal (Some (nv, n, k)))"
apply(auto simp:program_step.simps)
apply(cases k)
apply(auto)
apply(cases n)
apply(simp)
apply(cases "\<not> check_annotations v c")
apply(simp)
apply(simp)
apply(auto)
apply(cases "instruction_sem v c inst")
apply(auto)
apply(rule umpi_umpi)
apply(auto)

apply(cases inst)
apply(auto simp:no_return_bits no_return_sarith
  no_return_arith no_return_info no_return_dup
  no_return_memory no_return_storage no_return_pc
  no_return_stack no_return_swap no_return_log
  no_return_anno no_return_misc)
done

theorem simple_doesnt_return :
  "program_step c (Continue v n k) =
   Return (ProgramToWorld act stor bal (Some (nv, n, k))) \<Longrightarrow>
   will_return (venv_next_instruction v c)"
apply(cases "venv_next_instruction v c")
apply(auto simp:no_simple_return no_inst_error)
done

theorem expr_stop_aux5 :
  "program_step c (Continue v n k) =
   Return (ProgramToWorld act stor bal (Some (nv, n, k))) \<Longrightarrow>
   venv_next_instruction v c = Some (Misc STOP)"

theorem expr_stop :
  "eval_expr v addr (compile_expr expr) = Some res  \<Longrightarrow>
  \<exists> nv x e1 e2. program_iter
            (make_prog (compile_expr expr) addr) (Continue v 100 100) x =
          Continue nv e1 e2 \<and> 
          venv_next_instruction nv c = Some (Misc STOP)"
apply(auto simp:get_stack_top.simps)

theorem expr_correct :
"maybe_eq (eval_expr v addr (compile_expr expr)) (get_expr v expr)"
(* Theorem: expr_correct*)(* try *)
apply(induction expr)
apply(subst compile_expr.simps)
apply(subst get_expr.simps)
apply(rule simple_correct)
apply(subst compile_expr.simps)
apply(subst get_expr.simps)

end
