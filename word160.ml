(*Generated by Lem from word160.lem.*)
(*
  Copyright 2016 Sami MÃ¤kelÃ¤

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*)

open Lem_pervasives
open Lem_word

type word160 = W160 of Nat_big_num.num

(* perhaps should truncate here? *)
(*val bs_to_w160 : bitSequence -> word160*)
let bs_to_w160 seq:word160=  (W160 (integerFromBitSeq seq))

(*val w160_to_bs : word160 -> bitSequence*)
let w160_to_bs (W160 i):bitSequence=  (bitSeqFromInteger (Some( 160)) i)

(*val base : integer*)
let base:Nat_big_num.num= (Nat_big_num.pow_int(Nat_big_num.of_int 2)( 160))

(*val word160BinTest : forall 'a. (integer -> integer -> 'a) -> word160 -> word160 -> 'a*)
let word160BinTest binop (W160 w1) (W160 w2):'a=  (binop ( Nat_big_num.modulus w1 base) ( Nat_big_num.modulus w2 base))

(*val word160BBinTest : forall 'a. (bitSequence -> bitSequence -> 'a) -> word160 -> word160 -> 'a*)
let word160BBinTest binop w1 w2:'a=  (binop (w160_to_bs w1) (w160_to_bs w2))

(*val word160BinOp : (integer -> integer -> integer) -> word160 -> word160 -> word160*)
let word160BinOp binop (W160 w1) (W160 w2):word160=  (W160 ( Nat_big_num.modulus(binop ( Nat_big_num.modulus w1 base) ( Nat_big_num.modulus w2 base)) base))

(*val word160BBinOp : (bitSequence -> bitSequence -> bitSequence) -> word160 -> word160 -> word160*)
let word160BBinOp binop w1 w2:word160=  (bs_to_w160 (binop (w160_to_bs w1) (w160_to_bs w2)))

(*val word160NatOp : (integer -> nat -> integer) -> word160 -> nat -> word160*)
let word160NatOp binop (W160 w1) n:word160=  (W160  ( Nat_big_num.modulus(binop ( Nat_big_num.modulus w1 base) n) base))

(*val word160BNatOp : (bitSequence -> nat -> bitSequence) -> word160 -> nat -> word160*)
let word160BNatOp binop w1 n:word160=  (bs_to_w160 (binop (w160_to_bs w1) n))

(*val word160BUnaryOp : (bitSequence -> bitSequence) -> word160 -> word160*)
let word160BUnaryOp op w:word160=  (bs_to_w160 (op (w160_to_bs w)))

(*val word160UnaryOp : (integer -> integer) -> word160 -> word160*)
let word160UnaryOp op (W160 w):word160=  (W160 ( Nat_big_num.modulus(op w) base))

(*val word160ToNat : word160 -> nat*)
let word160ToNat w:int=  (abs (Nat_big_num.to_int (integerFromBitSeq (w160_to_bs w))))

(*val word160ToInt : word160 -> int*)
let word160ToInt w:int=  (Nat_big_num.to_int (integerFromBitSeq (w160_to_bs w)))

(*val word160FromInteger : integer -> word160*)
let word160FromInteger i:word160=  (W160 ( Nat_big_num.modulus i base))

(*val word160FromInt : int -> word160*)
let word160FromInt i:word160=  (W160 ( Nat_big_num.modulus(Nat_big_num.of_int i) base))

(*val word160FromNat : nat -> word160*)
let word160FromNat i:word160=  (word160FromInteger (Nat_big_num.of_int i))

(*val word160FromBoollist : list bool -> word160*)
let word160FromBoollist lst:word160=  ((match bitSeqFromBoolList lst with
 | None -> bs_to_w160(bitSeqFromInteger None (Nat_big_num.of_int 0))
 | Some a -> bs_to_w160 a
))

(*val boolListFromWord160 : word160 -> list bool*)
let boolListFromWord160 w:(bool)list=  (boolListFrombitSeq( 160) (w160_to_bs w))

(*val word160FromNumeral : numeral -> word160*)
let word160FromNumeral w:word160=  (W160 ( Nat_big_num.modulus(Nat_big_num.of_int w) base))

(*val w160Eq : word160 -> word160 -> bool*)
let w160Eq:word160 ->word160 ->bool=  (=)

(*val w160Less : word160 -> word160 -> bool*)
let w160Less bs1 bs2:bool=  (word160BinTest Nat_big_num.less bs1 bs2)

(*val w160LessEqual : word160 -> word160 -> bool*)
let w160LessEqual bs1 bs2:bool=  (word160BinTest Nat_big_num.less_equal bs1 bs2)

(*val w160Greater : word160 -> word160 -> bool*)
let w160Greater bs1 bs2:bool=  (word160BinTest Nat_big_num.greater bs1 bs2)

(*val w160GreaterEqual : word160 -> word160 -> bool*)
let w160GreaterEqual bs1 bs2:bool=  (word160BinTest Nat_big_num.greater_equal bs1 bs2)

(*val w160Compare : word160 -> word160 -> ordering*)
let w160Compare bs1 bs2:int=  (word160BinTest Nat_big_num.compare bs1 bs2)

let instance_Basic_classes_Ord_Word160_word160_dict:(word160)ord_class= ({

  compare_method = w160Compare;

  isLess_method = w160Less;

  isLessEqual_method = w160LessEqual;

  isGreater_method = w160Greater;

  isGreaterEqual_method = w160GreaterEqual})

let instance_Basic_classes_SetType_Word160_word160_dict:(word160)setType_class= ({

  setElemCompare_method = w160Compare})

(*val word160Negate : word160 -> word160*)
let word160Negate:word160 ->word160=  (word160UnaryOp Nat_big_num.negate)

(*val word160Succ : word160 -> word160*)
let word160Succ:word160 ->word160=  (word160UnaryOp Nat_big_num.succ)

(*val word160Pred : word160 -> word160*)
let word160Pred:word160 ->word160=  (word160UnaryOp Nat_big_num.pred)

(*val word160Lnot : word160 -> word160*)
let word160Lnot:word160 ->word160=  (word160UnaryOp integerLnot)

(*val word160Add : word160 -> word160 -> word160*)
let word160Add:word160 ->word160 ->word160=  (word160BinOp Nat_big_num.add)

(*val word160Minus : word160 -> word160 -> word160*)
let word160Minus:word160 ->word160 ->word160=  (word160BinOp Nat_big_num.sub)

(*val word160Mult : word160 -> word160 -> word160*)
let word160Mult:word160 ->word160 ->word160=  (word160BinOp Nat_big_num.mul)

(*val word160IntegerDivision : word160 -> word160 -> word160*)
let word160IntegerDivision:word160 ->word160 ->word160=  (word160BinOp Nat_big_num.div)

(*val word160Division : word160 -> word160 -> word160*)
let word160Division:word160 ->word160 ->word160=  (word160BinOp Nat_big_num.div)

(*val word160Remainder : word160 -> word160 -> word160*)
let word160Remainder:word160 ->word160 ->word160=  (word160BinOp Nat_big_num.modulus)

(*val word160Land : word160 -> word160 -> word160*)
let word160Land:word160 ->word160 ->word160=  (word160BinOp Nat_big_num.bitwise_and)

(*val word160Lor : word160 -> word160 -> word160*)
let word160Lor:word160 ->word160 ->word160=  (word160BinOp Nat_big_num.bitwise_or)

(*val word160Lxor : word160 -> word160 -> word160*)
let word160Lxor:word160 ->word160 ->word160=  (word160BinOp Nat_big_num.bitwise_xor)

(*val word160Min : word160 -> word160 -> word160*)
let word160Min:word160 ->word160 ->word160=  (word160BinOp (Nat_big_num.min))

(*val word160Max : word160 -> word160 -> word160*)
let word160Max:word160 ->word160 ->word160=  (word160BinOp (Nat_big_num.max))

(*val word160Power : word160 -> nat -> word160*)
let word160Power:word160 ->int ->word160=  (word160NatOp Nat_big_num.pow_int)

(*val word160Asr : word160 -> nat -> word160*)
let word160Asr:word160 ->int ->word160=  (word160NatOp Nat_big_num.shift_right)

(*val word160Lsr : word160 -> nat -> word160*)
let word160Lsr:word160 ->int ->word160=  (word160NatOp Nat_big_num.shift_right)

(*val word160Lsl : word160 -> nat -> word160*)
let word160Lsl:word160 ->int ->word160=  (word160NatOp Nat_big_num.shift_left)


let instance_Num_NumNegate_Word160_word160_dict:(word160)numNegate_class= ({

  numNegate_method = word160Negate})

let instance_Num_NumAdd_Word160_word160_dict:(word160)numAdd_class= ({

  numAdd_method = word160Add})

let instance_Num_NumMinus_Word160_word160_dict:(word160)numMinus_class= ({

  numMinus_method = word160Minus})

let instance_Num_NumSucc_Word160_word160_dict:(word160)numSucc_class= ({

  succ_method = word160Succ})

let instance_Num_NumPred_Word160_word160_dict:(word160)numPred_class= ({

  pred_method = word160Pred})

let instance_Num_NumMult_Word160_word160_dict:(word160)numMult_class= ({

  numMult_method = word160Mult})

let instance_Num_NumPow_Word160_word160_dict:(word160)numPow_class= ({

  numPow_method = word160Power})

let instance_Num_NumIntegerDivision_Word160_word160_dict:(word160)numIntegerDivision_class= ({

  div_method = word160IntegerDivision})

let instance_Num_NumDivision_Word160_word160_dict:(word160)numDivision_class= ({

  numDivision_method = word160Division})

let instance_Num_NumRemainder_Word160_word160_dict:(word160)numRemainder_class= ({

  mod_method = word160Remainder})

let instance_Basic_classes_OrdMaxMin_Word160_word160_dict:(word160)ordMaxMin_class= ({

  max_method = word160Max;

  min_method = word160Min})

let instance_Word_WordNot_Word160_word160_dict:(word160)wordNot_class= ({

  lnot_method = word160Lnot})

let instance_Word_WordAnd_Word160_word160_dict:(word160)wordAnd_class= ({

  land_method = word160Land})

let instance_Word_WordOr_Word160_word160_dict:(word160)wordOr_class= ({

  lor_method = word160Lor})

let instance_Word_WordXor_Word160_word160_dict:(word160)wordXor_class= ({

  lxor_method = word160Lxor})

let instance_Word_WordLsl_Word160_word160_dict:(word160)wordLsl_class= ({

  lsl_method = word160Lsl})

let instance_Word_WordLsr_Word160_word160_dict:(word160)wordLsr_class= ({

  lsr_method = word160Lsr})

let instance_Word_WordAsr_Word160_word160_dict:(word160)wordAsr_class= ({

  asr_method = word160Asr})

(*val word160UGT : word160 -> word160 -> bool*)
let word160UGT a b:bool=  (word160ToNat a > word160ToNat b)

