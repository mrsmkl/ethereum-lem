(*Generated by Lem from word8.lem.*)
(*
  Copyright 2016 Sami MÃ¤kelÃ¤

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*)

open Lem_pervasives
open Lem_word

type word8 = W8 of Nat_big_num.num

(* perhaps should truncate here? *)
(*val bs_to_w8 : bitSequence -> word8*)
let bs_to_w8 seq:word8=  (W8 (integerFromBitSeq seq))

(*val w8_to_bs : word8 -> bitSequence*)
let w8_to_bs (W8 i):bitSequence=  (bitSeqFromInteger (Some( 8)) i)

(*val base : integer*)
let base:Nat_big_num.num= (Nat_big_num.pow_int(Nat_big_num.of_int 2)( 8))

(*val word8BinTest : forall 'a. (integer -> integer -> 'a) -> word8 -> word8 -> 'a*)
let word8BinTest binop (W8 w1) (W8 w2):'a=  (binop ( Nat_big_num.modulus w1 base) ( Nat_big_num.modulus w2 base))

(*val word8BBinTest : forall 'a. (bitSequence -> bitSequence -> 'a) -> word8 -> word8 -> 'a*)
let word8BBinTest binop w1 w2:'a=  (binop (w8_to_bs w1) (w8_to_bs w2))

(*val word8BinOp : (integer -> integer -> integer) -> word8 -> word8 -> word8*)
let word8BinOp binop (W8 w1) (W8 w2):word8=  (W8 ( Nat_big_num.modulus(binop ( Nat_big_num.modulus w1 base) ( Nat_big_num.modulus w2 base)) base))

(*val word8BBinOp : (bitSequence -> bitSequence -> bitSequence) -> word8 -> word8 -> word8*)
let word8BBinOp binop w1 w2:word8=  (bs_to_w8 (binop (w8_to_bs w1) (w8_to_bs w2)))

(*val word8NatOp : (integer -> nat -> integer) -> word8 -> nat -> word8*)
let word8NatOp binop (W8 w1) n:word8=  (W8  ( Nat_big_num.modulus(binop ( Nat_big_num.modulus w1 base) n) base))

(*val word8BNatOp : (bitSequence -> nat -> bitSequence) -> word8 -> nat -> word8*)
let word8BNatOp binop w1 n:word8=  (bs_to_w8 (binop (w8_to_bs w1) n))

(*val word8BUnaryOp : (bitSequence -> bitSequence) -> word8 -> word8*)
let word8BUnaryOp op w:word8=  (bs_to_w8 (op (w8_to_bs w)))

(*val word8UnaryOp : (integer -> integer) -> word8 -> word8*)
let word8UnaryOp op (W8 w):word8=  (W8 ( Nat_big_num.modulus(op w) base))

(*val word8ToNat : word8 -> nat*)
let word8ToNat w:int=  (abs (Nat_big_num.to_int (integerFromBitSeq (w8_to_bs w))))

(*val word8ToInt : word8 -> int*)
let word8ToInt w:int=  (Nat_big_num.to_int (integerFromBitSeq (w8_to_bs w)))

(*val word8FromInteger : integer -> word8*)
let word8FromInteger i:word8=  (W8 ( Nat_big_num.modulus i base))

(*val word8FromInt : int -> word8*)
let word8FromInt i:word8=  (W8 ( Nat_big_num.modulus(Nat_big_num.of_int i) base))

(*val word8FromNat : nat -> word8*)
let word8FromNat i:word8=  (word8FromInteger (Nat_big_num.of_int i))

(*val word8FromBoollist : list bool -> word8*)
let word8FromBoollist lst:word8=  ((match bitSeqFromBoolList lst with
 | None -> bs_to_w8(bitSeqFromInteger None (Nat_big_num.of_int 0))
 | Some a -> bs_to_w8 a
))

(*val boolListFromWord8 : word8 -> list bool*)
let boolListFromWord8 w:(bool)list=  (boolListFrombitSeq( 8) (w8_to_bs w))

(*val word8FromNumeral : numeral -> word8*)
let word8FromNumeral w:word8=  (W8 ( Nat_big_num.modulus(Nat_big_num.of_int w) base))

(*val w8Eq : word8 -> word8 -> bool*)
let w8Eq:word8 ->word8 ->bool=  (=)

(*val w8Less : word8 -> word8 -> bool*)
let w8Less bs1 bs2:bool=  (word8BinTest Nat_big_num.less bs1 bs2)

(*val w8LessEqual : word8 -> word8 -> bool*)
let w8LessEqual bs1 bs2:bool=  (word8BinTest Nat_big_num.less_equal bs1 bs2)

(*val w8Greater : word8 -> word8 -> bool*)
let w8Greater bs1 bs2:bool=  (word8BinTest Nat_big_num.greater bs1 bs2)

(*val w8GreaterEqual : word8 -> word8 -> bool*)
let w8GreaterEqual bs1 bs2:bool=  (word8BinTest Nat_big_num.greater_equal bs1 bs2)

(*val w8Compare : word8 -> word8 -> ordering*)
let w8Compare bs1 bs2:int=  (word8BinTest Nat_big_num.compare bs1 bs2)

let instance_Basic_classes_Ord_Word8_word8_dict:(word8)ord_class= ({

  compare_method = w8Compare;

  isLess_method = w8Less;

  isLessEqual_method = w8LessEqual;

  isGreater_method = w8Greater;

  isGreaterEqual_method = w8GreaterEqual})

let instance_Basic_classes_SetType_Word8_word8_dict:(word8)setType_class= ({

  setElemCompare_method = w8Compare})

(*val word8Negate : word8 -> word8*)
let word8Negate:word8 ->word8=  (word8UnaryOp Nat_big_num.negate)

(*val word8Succ : word8 -> word8*)
let word8Succ:word8 ->word8=  (word8UnaryOp Nat_big_num.succ)

(*val word8Pred : word8 -> word8*)
let word8Pred:word8 ->word8=  (word8UnaryOp Nat_big_num.pred)

(*val word8Lnot : word8 -> word8*)
let word8Lnot:word8 ->word8=  (word8UnaryOp integerLnot)

(*val word8Add : word8 -> word8 -> word8*)
let word8Add:word8 ->word8 ->word8=  (word8BinOp Nat_big_num.add)

(*val word8Minus : word8 -> word8 -> word8*)
let word8Minus:word8 ->word8 ->word8=  (word8BinOp Nat_big_num.sub)

(*val word8Mult : word8 -> word8 -> word8*)
let word8Mult:word8 ->word8 ->word8=  (word8BinOp Nat_big_num.mul)

(*val word8IntegerDivision : word8 -> word8 -> word8*)
let word8IntegerDivision:word8 ->word8 ->word8=  (word8BinOp Nat_big_num.div)

(*val word8Division : word8 -> word8 -> word8*)
let word8Division:word8 ->word8 ->word8=  (word8BinOp Nat_big_num.div)

(*val word8Remainder : word8 -> word8 -> word8*)
let word8Remainder:word8 ->word8 ->word8=  (word8BinOp Nat_big_num.modulus)

(*val word8Land : word8 -> word8 -> word8*)
let word8Land:word8 ->word8 ->word8=  (word8BinOp Nat_big_num.bitwise_and)

(*val word8Lor : word8 -> word8 -> word8*)
let word8Lor:word8 ->word8 ->word8=  (word8BinOp Nat_big_num.bitwise_or)

(*val word8Lxor : word8 -> word8 -> word8*)
let word8Lxor:word8 ->word8 ->word8=  (word8BinOp Nat_big_num.bitwise_xor)

(*val word8Min : word8 -> word8 -> word8*)
let word8Min:word8 ->word8 ->word8=  (word8BinOp (Nat_big_num.min))

(*val word8Max : word8 -> word8 -> word8*)
let word8Max:word8 ->word8 ->word8=  (word8BinOp (Nat_big_num.max))

(*val word8Power : word8 -> nat -> word8*)
let word8Power:word8 ->int ->word8=  (word8NatOp Nat_big_num.pow_int)

(*val word8Asr : word8 -> nat -> word8*)
let word8Asr:word8 ->int ->word8=  (word8NatOp Nat_big_num.shift_right)

(*val word8Lsr : word8 -> nat -> word8*)
let word8Lsr:word8 ->int ->word8=  (word8NatOp Nat_big_num.shift_right)

(*val word8Lsl : word8 -> nat -> word8*)
let word8Lsl:word8 ->int ->word8=  (word8NatOp Nat_big_num.shift_left)


let instance_Num_NumNegate_Word8_word8_dict:(word8)numNegate_class= ({

  numNegate_method = word8Negate})

let instance_Num_NumAdd_Word8_word8_dict:(word8)numAdd_class= ({

  numAdd_method = word8Add})

let instance_Num_NumMinus_Word8_word8_dict:(word8)numMinus_class= ({

  numMinus_method = word8Minus})

let instance_Num_NumSucc_Word8_word8_dict:(word8)numSucc_class= ({

  succ_method = word8Succ})

let instance_Num_NumPred_Word8_word8_dict:(word8)numPred_class= ({

  pred_method = word8Pred})

let instance_Num_NumMult_Word8_word8_dict:(word8)numMult_class= ({

  numMult_method = word8Mult})

let instance_Num_NumPow_Word8_word8_dict:(word8)numPow_class= ({

  numPow_method = word8Power})

let instance_Num_NumIntegerDivision_Word8_word8_dict:(word8)numIntegerDivision_class= ({

  div_method = word8IntegerDivision})

let instance_Num_NumDivision_Word8_word8_dict:(word8)numDivision_class= ({

  numDivision_method = word8Division})

let instance_Num_NumRemainder_Word8_word8_dict:(word8)numRemainder_class= ({

  mod_method = word8Remainder})

let instance_Basic_classes_OrdMaxMin_Word8_word8_dict:(word8)ordMaxMin_class= ({

  max_method = word8Max;

  min_method = word8Min})

let instance_Word_WordNot_Word8_word8_dict:(word8)wordNot_class= ({

  lnot_method = word8Lnot})

let instance_Word_WordAnd_Word8_word8_dict:(word8)wordAnd_class= ({

  land_method = word8Land})

let instance_Word_WordOr_Word8_word8_dict:(word8)wordOr_class= ({

  lor_method = word8Lor})

let instance_Word_WordXor_Word8_word8_dict:(word8)wordXor_class= ({

  lxor_method = word8Lxor})

let instance_Word_WordLsl_Word8_word8_dict:(word8)wordLsl_class= ({

  lsl_method = word8Lsl})

let instance_Word_WordLsr_Word8_word8_dict:(word8)wordLsr_class= ({

  lsr_method = word8Lsr})

let instance_Word_WordAsr_Word8_word8_dict:(word8)wordAsr_class= ({

  asr_method = word8Asr})

(*val word8UGT : word8 -> word8 -> bool*)
let word8UGT a b:bool=  (word8ToNat a > word8ToNat b)

